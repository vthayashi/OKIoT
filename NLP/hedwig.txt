\chapter{Arquitetura: Tecnologia - Aprendizado de Máquina}

	O termo Aprendizado de Máquina (\emph{Machine Learning}) surgiu em 1959, sendo utilizado pela primeira vez  pelo cientista americano Arthur Samuel. O termo foi por ele definido como ``o campo de estudos que dá a um computador a habilidade de aprender sem ser explicitamente programado'' (tradução livre dos autores). Em 1998, Tom Mitchel --- outro cientista da computação americano --- propôs uma explicação menos abstrata do termo da seguinte maneira: ``um programa de computador aprende com a experiência E com respeito a uma classe de tarefas T e medida de performance P se sua performace nas tarefas T, sendo medida por P, aumenta com o aumento da experiência E'' \cite{Coursera}.

	Apesar do conceito de aprendizado de máquina existir desde a década de 50, seu crescimento e relevância aumentaram apenas na última década. Alguns fatores levaram a esse crescimento acelerado: os principais foram o aumento da quantidade de dados coletados e disponíveis --- e aplicações de \emph{IoT} têm propulsionado esse aumento --- a melhora nos algoritmos e o \emph{hardware} cada vez mais poderoso dos computadores. Esses últimos dois fatores permitem que uma vasta quantidade de dados possa ser analisada em tempo viável \cite{hbrMlExplosion}.

	\section{Aprendizado de Máquina no Projeto Hedwig}\label{aprendizadoDeMaquinaNoProjetoHedwig}

		No projeto Hedwig, a utilização de aprendizado de máquina tem o intuito de trazer melhorias de usabilidade do sistema ao usuário, além de trazer medidas de segurança à casa.

		As melhorias de usabilidade podem ocorrer, por exemplo, quando o sistema aprende alguma rotina do usuário e se torna então capaz de prever quando determinada ação seria solicitada. A partir disso, ele poderia passar a realizar tal ação automaticamente ou sugerir a sua realização, sem a requisição explícita do usuário.

		No quesito de segurança, o sistema pode, a partir do aprendizado de rotinas, detectar ações suspeitas na casa, como por exemplo a abertura da porta de entrada em horário não usual, e opcionalmente agir para intervir quando tal tipo de ação é detectada.

		No Hedwig, foi desenvolvida uma análise baseada em dados coletados durante os meses de setembro e outubro, em um dos módulos instalados --- o módulo de corredor, que já foi citado no Capítulo \ref{coletaAnaliseDados}. A análise aqui descrita focou-se em gerar um algoritmo capaz de prever quando o usuário solicitaria ao sistema a ativação do relé 1, que, no caso do módulo em análise, está conectado à lâmpada do corredor. Como analisado na Capítulo \ref{coletaAnaliseDados}, a funcionalidade de agendamento de ativação desse relé foi pouco aproveitada, já que também houveram muitas ativações manuais, indicando que o usuário poderia se beneficiar de um algoritmo inteligente que pudesse prever a ativação do relé antes da solicitação do usuário.

	\section{Implementação}

		\subsection{Linguagem, Ferramentas e Bibliotecas}

			Uma das vantagens da popularização que se vê atualmente do uso de aprendizado de máquina é o surgimento de muitas facilidades para o desenvolvimento de aplicações que envolvam esse tema, devido às vantagens que advém da existência de uma grande comunidade trabalhando no assunto.

			Atualmente duas das principais linguagens sendo utilizadas para ciência de dados e aprendizado de máquina e que foram consideradas para o projeto, são Python e R \cite{languagesForML}. As duas são linguagens interpretadas e possuem funcionalidade REPL (\emph{Read-Eval-Print-Loop}), possibilitando desenvolvimento altamente interativo, além da fácil visualização de dados e gráficos enquanto se programa.

			Para o desenvolvimento de funcionalidades de aprendizado de máquina no Hedwig, foi escolhida a linguagem Python. Apesar de R ser uma linguagem que já nasceu voltada à análise de dados e tratamento estatístico \cite{rLanguage}, Python possui diversos pacotes e bibliotecas responsáveis por adicionar tais funcionalidades. Esses pacotes são altamente popularizados, e é simples percorrer suas documentações e procurar ajuda em fóruns online para acelerar o aprendizado. Python, por sua vez, é uma linguagem de uso geral (\emph{general purpose language}), o que o torna vantajoso \cite{pythonApplications}. Além de ser uma linguagem extremamente bem estabelecida, o fato de ser de uso geral implica que existem também pacotes e bibliotecas que possibilitam o uso de Python para desenvolvimento de aplicativos com funcionalidades de \emph{back-end} para serviços \emph{web}. Isso se torna altamente interessante por possibilitar a transformação de uma aplicação em um microsserviço que interaja em tempo real com o servidor em nuvem do Hedwig, permitindo que o serviço de aprendizado de máquina aja em tempo real com toda a aplicação.

			Os principais pacotes sendo utilizados para auxiliar nas funcionalidades de análise de dados e aprendizado de máquina são:

			\begin{description}
				\item [Numpy\footnote{http://www.numpy.org/}] Pacote que dá à linguagem Python algumas facilidades para se lidar com estruturas numéricas, como matrizes.
				\item [Pandas\footnote{https://pandas.pydata.org/}] Pacote para manuseio de dados. Promove facilidades para a importação de dados de fontes externas, bem como sua utilização..
				\item [Scikit\footnote{http://scikit-learn.org/stable/}] Pacote com funcionalidades de análise de dados e implementação dos principais algoritmos de aprendizado de máquina.
				\item [Matplotlib\footnote{https://matplotlib.org/}] Pacote que implementa funcionalidades para geração de gráficos.
			\end{description}

			A principal ferramenta utilizada durante o desenvolvimento de código de aprendizado de máquina chama-se Jupyter Notebook \footnote{http://jupyter.org/}. Essa ferramenta é uma aplicação \emph{web} de distribuição gratuita, que permite a criação e compartilhamento de documentos com código que pode ser interpretado interativamente. Junto dos trechos de código executado, coloca suas saídas, bem como gráficos gerados pelo trecho, além de permitir ao usuário colocar explicações ou textos gerais em linguagem \textit{Markdown}, em meio ao código, de forma a explicá-lo. É uma ferramenta altamente utilizada para aplicações de análise de dados atualmente.

		\subsection{Etapas para o Desenvolvimento de Aplicação de Aprendizado de Máquina}

			O desenvolvimento de aplicações de aprendizado de máquina é caracterizado por algumas etapas \cite{whatIsML}.

			Inicialmente, é necessário explicitar qual o problema a ser resolvido. Na Seção \ref{aprendizadoDeMaquinaNoProjetoHedwig} foi exposto o problema aqui explorado.

			O próximo passo é a coleta de dados para que os modelos possam ser treinados. Expusemos essa etapa no Capítulo \ref{coletaAnaliseDados}.

			Em seguida, é necessário realizar algumas análises e tratamentos de dados para que se possa sanitizá-los e deixá-los em formato propício ao uso pelos algoritmos. Também é necessário separar uma parcela dos dados para servir para treinamento dos modelos e outra parcela para servir de dados de teste.

			Tendo isso pronto, pode-se então passar a uma etapa de treinamento de modelos. Para isso, é necessário fazer uma análise de quais algoritmos poderiam se encaixar bem para o problema em questão. A partir do treinamento dos modelos e da separação de alguns dados para teste, é possível então avaliar quão bem os algoritmos estão performando para a previsão de resultados, e possivelmente, adotar uma abordagem diferente para o treinamento dos modelos.

			O último passo costuma ser a elaboração do produto final: normalmente a integração do sistema de aprendizado com outras aplicações ou então a elaboração de relatórios para que os modelos treinados para o problema sejam levados adiante. No caso de um produto integrado com o resto de um sistema, passa-se então a entrar num ciclo de otimização do algoritmo baseado em novos dados obtidos.

			Nas próximas subseções serão explorados o desenvolvimento desses últimos passos no projeto Hedwig.

		\subsection{Algoritmos}

			Existem duas classificações gerais para algoritmos de aprendizado de máquina: os de aprendizado supervisionado e os de aprendizado não-supervisionado. Os algoritmos de aprendizado supervisionado são caracterizados por tratarem de problemas nos quais se espera conseguir prever uma determinada saída baseada em um ou mais dados de entrada. Já os algoritmos de aprendizado não-supervisionado se caracterizam por tratarem de casos nos quais não há uma saída supervisionada. Nesses casos, o objetivo é apenas de encontrar algum relacionamento ou estrutura nos dados de entrada \cite{islr}. O caso aqui estudado encaixa-se na definição de aprendizado supervisionado, já que temos nos dados de treinamento as saídas que desejamos que o modelo consiga prever.

			Dentro do campo de aprendizado supervisionado os algoritmos são divididos tem relação ao tipo de resposta que se espera deles. Há dois tipos principais de resposta: qualitativa e quantitativa  \cite{islr}. Os problemas para os quais a saída é uma variável quantitativa são chamados de problemas de regressão. Um dos métodos mais comuns para se tratar esse tipo de problema é o da regressão linear com utilização do método dos mínimos quadrados.

			Para os problemas nos quais a saída esperada é uma variável qualitativa, o nome dado é de problemas de classificação - já que o que se deseja obter como resposta é a qual classe a resposta pertence. Um tipo de algoritmo que costuma ser utilizado para problemas desse tipo é o de regressão logística.

			Adicionalmente, vale citar que há alguns tipos de algoritmos que podem ser utilizados tanto para problemas quantitativos quanto para problemas qualitativos, dentre eles: K-vizinhos mais próximos (\emph{K-nearest neighbors}) e \emph{boosting} \cite{islr}.

			O algoritmo aqui em desenvolvimento então pode ser classificado como aprendizado supervisionado, de classificação (já que a saída esperada é do tipo ``Sim, o usuário provavelmente gostaria de acender a luz nesse momento'' ou ``Não, o usuário provavelmente não gostaria de acender a luz'').

		\subsection{Tratamento de Dados}
			
			Neste primeiro estudo, o objetivo é o desenvolvimento de um modelo que aprenda a prever quando ocorrerá uma ativação do relé pelo usuário. No problema em análise, os dados que possuímos são:

			\begin{itemize}
				\item \emph{Timestamp} com dia e hora
				\item Luminosidade
				\item Temperatura
				\item Umidade
				\item Presença
				\item Ativação do relé (para o relé 1 e para o relé 2)
				\item Tipo de ativação (via botão, aplicativo backup, controle remoto ou ativação agendada)
				\item Status dos relés
			\end{itemize}

			Para que seja possível utilizar tais dados, alguns tratamentos são necessários.

			A primeira característica observada foi que as primeiras entradas de dados ainda estavam incompletas e não possuíam dados a respeito do estado corrente dos relés. Essas entradas foram então descartadas, já que não permitiriam saber se a ação executada pelo usuário foi para acender ou apagar as luzes, e deseja-se selecionar apenas os casos relativos ao acendimento da luz.

			Em seguida, foi levado em consideração que a ativação pode ter ocorrido em decorrência de um agendamento. Nesse caso, portanto, devemos desconsiderar essa ativação, já que não se trata de uma ativação do usuário e não nos ajuda a prever quando o usuário irá desejar ativar o relé.

			Outro simples tratamento necessário foi o tratamento do \emph{timestamp}. O valor de interesse no estudo atual é apenas o referente ao instante no dia em que ocorreu a ativação (horas, minutos, segundos), relevando-se a informação do dia em si que tal evento foi capturado. Dessa forma, foi separada apenas a componente de horário dos \emph{timestamps}, que foi convertida para um número inteiro referente à quantidade de segundos desde a meia noite.

			Outra questão a ser levada em consideração é a presença de uma disparidade entre a quantidade de amostras de treino que estão em uma classificação em relação à quantidade que está em outra. No caso em análise, existem muito mais dados nos quais não ocorreu ativação do relé pelo usuário (71) do que os que ocorreram (6851). Ou seja, aproximadamente 99\% dos dados estão em uma classificação, e apenas 1\% na outra. Essa situação é conhecida como \emph{Class Imbalance Problem} \cite{classImbalanceProblem}. Essa disparidade é um problema devido ao fato de que os algoritmos classificadores têm como objetivo a maximização da sua taxa de acerto. Dessa forma, há alta tendência a sempre classificar os dados como pertencentes à classe majoritária. Isso é um problema principalmente em casos nos quais as situações de interesse são exatamente as que menos ocorrem, como é o caso do problema aqui em exploração. Para resolvê-lo, há duas táticas principais: \emph{oversampling} e \emph{undersampling}.

			As duas táticas procuram balancear a quantidade de amostras em cada uma das classes. Pela tática de \emph{undersampling} isso é feito retirando-se algumas amostras da classe majoritária. Pela tática de \emph{oversampling}, isso é feito adicionando-se amostras da classe minoritária. Também existe a tática híbrida, que combina as duas anteriores.

			A desvantagem da técnica de \emph{undersampling} é que acaba por descartar dados potencialmente úteis. Já a técnica de \emph{oversampling} muitas vezes pode levar ao \emph{overfitting} (fenômeno que ocorre em situações nas quais o modelo acaba acompanhando muito proximamente os erros --- ou ruído --- dos dados de treinamento \cite{islr}), devido às cópias que são feitas de alguns dados de treinamento \cite{unbalancedClassArticle}.

			Algumas técnicas diferentes de \emph{oversampling} e \emph{undersampling} foram aplicadas. Os gráficos abaixo ajudam a compreender a diferença que a aplicação de tais técnicas causa nos dados que serão utilizados para treinamento dos modelos em seguida.

			Primeiramente, analisou-sem a relação entre luminosidade e hora do dia e a ativação da luminária. Obteve-se então o seguinte gráfico:

			\begin{figure}[H]
				\centering
				\caption{Relação entre luminosidade e hora do dia e a ativação da luminária}
				\includegraphics[width=0.7\textwidth]{DadosML_original}
				\label{fig:DadosML_original}
			\end{figure}

			Em seguida obteve-se os seguintes gráficos, com a utilização de diferentes técnicas para lidar com a situação de discrepância na quantidade de dados de treinamento cuja saída pertencia à classe de não-ativação do relé, em relação aos cuja saída pertencia à classe de ativação do relé.

			\begin{figure}[H]
				\centering
				\caption{Relação entre luminosidade e hora do dia e a ativação da luminária, com aplicação de técnica de \emph{random oversampling}}
				\includegraphics[width=0.7\textwidth]{DadosML_random_oversampling}
				\label{fig:DadosML_random_oversampling}
			\end{figure}

			\begin{figure}[H]
				\centering
				\caption{Relação entre luminosidade e hora do dia e a ativação da luminária, com aplicação de técnica \emph{SMOTE} \cite{SMOTE}}
				\includegraphics[width=0.7\textwidth]{DadosML_smote}
				\label{fig:DadosML_smote}
			\end{figure}

			\begin{figure}[H]
				\centering
				\caption{Relação entre luminosidade e hora do dia e a ativação da luminária, com aplicação de técnica de \emph{undersampling}}
				\includegraphics[width=0.7\textwidth]{DadosML_undersampling}
				\label{fig:DadosML_undersampling}
			\end{figure}

			\begin{figure}[H]
				\centering
				\caption{Relação entre luminosidade e hora do dia e a ativação da luminária, com aplicação de técnica híbrida de \emph{oversampling} e \emph{undersampling}}
				\includegraphics[width=0.7\textwidth]{DadosML_both}
				\label{fig:DadosML_both}
			\end{figure}

		\subsection{Treinamento dos Modelos}

			Em aprendizado de máquina, há diversos métodos de se treinar modelos. Nenhum deles será o melhor para todos os possíveis \emph{data sets}, e, portanto, a escolha da melhor abordagem é sempre uma parte importante do desenvolvimento de aprendizado de máquina \cite{islr}. Dessa forma, foram analisados diversos métodos.

			Foram utilizados três dos classificadores (como são chamados os algoritmos para treinar modelos de aprendizado de máquina no caso de aprendizado supervisionado para classificação) mais utilizados: regressão logística, análise discriminante linear e K-vizinhos mais próximos \cite{islr}.

			Os algoritmos utilizados para esses classificadores foram os do pacote Scikit\footnote{http://scikit-learn.org/stable/}.

			Para o treinamento dos modelos, os dados são particionados entre dados para treinamento e dados para teste. Os dados para teste são os utilizados para verificar a acurácia do modelo para prever resultados, utilizando tais dados para verificar se as saídas previstas foram as esperadas. Para fazer essa divisão, foi utilizada a função \texttt{train\_test\_split} do pacote Scikit\footnote{\url{http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html}}.

			Antes de se tratar o problema de desbalanceamento de classes, o algoritmo que melhor performou foi o de regressão logística, com precisão de 98,95\% nos dados de teste. Tal medida foi feita utilizando a função \texttt{score}, pertencente aos classificadores do Scikit.

			Em seguida, modificaram-se os dados de treinamento para tratar a questão de desbalanceamento de classes. Para isso, foram utilizadas diversas funções pertencentes ao pacote Imbalanced learn \footnote{\url{http://contrib.scikit-learn.org/imbalanced-learn/stable/index.html}}.

			Utilizando-se a técnica de \emph{random over sampling}, o algoritmo com maior taxa de acerto foi o de K vizinhos mais próximos, com acerto na previsão da saída em 96,02\% dos casos de teste. Aplicando \emph{oversampling} com a técnica \emph{SMOTE}, o melhor algoritmo também foi o de K vizinhos mais próximos, dessa vez com taxa de 80,39\% de acertos. Já com a técnica de \emph{undersampling}, a melhor taxa de acerto obtida foi de 72,34\%, com o algoritmo de análise discriminante linear. Por último, realizou-se um teste utilizando um misto das técnicas de \emph{oversampling} e \emph{undersampling}, obtendo-se uma taxa de 79,04\% de acerto nos casos de teste com o algoritmo de K vizinhos mais próximos.

		\subsection{Otimização dos Modelos}

			Pela análise aqui realizada, o modelo que pareceu ter a melhor performance foi o com utilização do algoritmo de K vizinhos mais próximos, com utilização da técnica de \emph{random over sampling}.

			Entretanto, outra métrica interessante de ser levada em consideração é o \emph{recall} para os casos de classificação na classe de ativação do relé. O \emph{recall} pode ser descrito como a razão entre \texttt{tp} e \texttt{tp + fn}, onde \texttt{tp} é  o número de positivos verdadeiros e \texttt{fn} é o número de falsos negativos. Dessa forma, o \emph{recall} pode ser visto como a habilidade do classificador de encontrar todas as amostras positivas \cite{precisionAndRecall}. Na situação em análise, pode-se traçar a hipótese que o mais importante para o usuário é o acerto das situações onde gostaria de ter a luz acendida, ou seja, que o mais importante seja encontrar todas as amostras positivas. Nesse caso, seria interessante então considerar o caso com melhor valor de \emph{recall} para a classificação de ativação da luminária. Isso ocorreu na situação de \emph{undersampling}, onde a taxa de \emph{recall} para essa classificação foi de 83\% --- valor que foi encontrado com a utilização da função \texttt{classification\_report}, do pacote Scikit\footnote{\url{http://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html}}.

			De qualquer forma, é importante ressaltar que para que o sistema torne-se cada vez mais acurado, o objetivo seria continuar alimentando-o com novos dados de entrada. Além disso, novos algoritmos e técnicas poderiam ser testados, a fim de continuar a exploração e comparação para encontrar o algoritmo de melhor performance para o sistema em questão.

			Outros tipos de testes poderiam ser feitos também em relação aos dados de entrada, utilizando-se técnicas de seleção de características, técnicas como \emph{mean normalization} ou \emph{feature scaling} \cite{Coursera}, observando-se a diferença no modelo treinado de forma a otimizar a performance deste.
\chapter{Arquitetura: Tecnologia - Coleta e Análise de Dados \label{coletaAnaliseDados}}

Um dos processos mais críticos para o sucesso de um projeto é a obtenção de resultados e dados, dos quais se obtém conhecimento sobre o comportamento do sistema em atividade e dos usuários que o utilizam.

\section{Coleta}

Para a coleta de dados, foram usados um total de oito módulos distribuídos em locais e residências diferentes, de modo a simular maior diversidade de utilização.

\begin{enumerate}
	\item Aquário
	\item Corredor
	\item Lavanderia
	\item Sala/Cozinha
	\item Entrada
	\item Caixa d’água
	\item Victor
	\item Jarinu
	\item Daniela
	\item Hugo
	\item Gabriela
\end{enumerate}

Os módulos de 1 a 7 estão localizados na mesma residência, em Santo André e o módulo 8 está localizado na cidade de Jarinu - SP. Já os módulos 9, 10 e 11 estão em casas diferentes na Grande São Paulo, e foram usados para desenvolvimento integrado de \textit{dashboard} e Aplicativo Backup.

\begin{figure}[H]
	\centering
	\caption{Log na página do Aplicativo Backup}
	\includegraphics[width=0.5\textwidth]{logAppBackup}
	\label{fig:logAppBackup}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Módulo com cartão SD para coleta local de dados}
	\includegraphics[width=0.3\textwidth]{SDColetaDados}
	\label{fig:SDColetaDados}
\end{figure}

Para os módulos em Santo André, foi utilizado um dispositivo com cartão SD para persistência de dados. Sua análise tem como objetivo principal acompanhar parâmetros relacionados à disponibilidade com coleta local.

\begin{figure}[H]
	\centering
	\caption{Módulos instalados em Santo André}
	\includegraphics[width=0.8\textwidth]{ModulosStoAndre}
	\label{fig:ModulosStoAndre}
\end{figure}

O módulo de Jarinu possui uma interface com o sistema de alarmes já instalado no local e tem como objetivo obter dados de presença e abertura de portas, sendo uma prova de conceito para validar possível integração futura com parceiros estratégicos (e.g. Empresas de Segurança Residencial e Empresarial).

\begin{figure}[H]
	\centering
	\caption{Controle do Sistema de Alarme e Módulo de Interface de Jarinu}
	\includegraphics[width=0.8\textwidth]{ModuloSistAlarme}
	\label{fig:ModuloSistAlarme}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Módulo Básico e sensor de presença no corredor de Jarinu}
	\includegraphics[width=0.5\textwidth]{BasicSensorPresJarinu}
	\label{fig:BasicSensorPresJarinu}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Sensor de abertura das portas da cozinha (à esquerda) e da sala (à direita)}
	\includegraphics[width=0.5\textwidth]{SensorPortasJarinu}
	\label{fig:SensorPortasJarinu}
\end{figure}

Os demais módulos usados para integração possuem coleta de dados a partir de persistência na nuvem, com as mensagens passando pelo controlador local Morpheus.

\begin{figure}[H]
	\centering
	\caption{Módulo instalado para coleta de dados do nível da caixa d’água}
	\includegraphics[width=0.8\textwidth]{ModuloCxAgua}
	\label{fig:ModuloCxAgua}
\end{figure}

Conforme destacado, os dados a seguir foram coletados localmente e possuem informações sobre disponibilidade e uso das funções pelo aplicativo backup, também com escopo local.

De modo geral, há a coleta dos seguintes dados:

\begin{figure}[H]
	\centering
	\caption{Relação dos módulos e dados coletados}
	\includegraphics[width=1.0\textwidth]{DiagramaModulosDados}
	\label{fig:DiagramaModulosDados}
\end{figure}

Foram coletados dados desde o dia 10 de setembro de 2017 até o dia 13 de novembro de 2017, com processo semanal de backup. Os dados foram segregados, suas duplicatas foram removidas e os conteúdos dos diversos arquivos de log foram consolidados.

\begin{itemize}
	\item \textbf{Dados do aquário}: temperatura da água, estado do aquecedor e estado da lâmpada usada como fonte de iluminação artificial.
	\item \textbf{Dados de disponibilidade}: memória livre disponível (“\emph{free heap}”), pois em casos de pouca memória disponível o espaço de dados invade o espaço de programa e ocorre travamento do ESP; monitoramento do contador de loops de 1 segundo que, devido à espera ou demasiado processamento, demoraram mais que 2 segundos para ocorrerem; monitoramento de desconexões, reconexões, atualizações do \emph{firmware} dos módulos e reinícios;
	\item \textbf{Luminosidade}: monitoramento a partir de dado analógico de um LDR.
	\item \textbf{Temperatura e umidade}: sensor DHT.
	\item \textbf{Presença}: sensor de movimento PIR, que foi usado para monitorar a atividade de presença.
	\item \textbf{Uso dos relés}: pelo botão físico presente no módulo, pela página web do aplicativo backup, automaticamente por regras configuradas pelo usuário e por controle de radiofrequência (RF) --- nos módulos usados para coleta e período de coleta, não havia ainda a \textit{dashboard} disponível.
	\item \textbf{Abertura e estado do portão}: monitoramento do estado do portão por sensor eletromagnético com fio, conectado diretamente ao módulo, e acompanhamento das aberturas por pessoa (Fabio, Victor ou Admin, que representa alguma das outras duas pessoas da casa), uso do sistema (aberturas pelo sensor versus aberturas pelo sistema) e monitoramento de uma porta intermediária da escada, por meio de sensor de abertura sem fio (comunicação por radiofrequência).
	\item \textbf{Nível máximo da caixa d’água}: sensor de boia próximo ao nível máximo.
	\item \textbf{Porta da sala (estado) e presença (corredor e cozinha) de Jarinu}: equipamentos próprios do sistema de alarmes.

\end{itemize}

\section{Análise}

\begin{table}[H]
    \caption{Análise consolidada de disponibilidade}
    \setlength\tabcolsep{1.5pt}
    \centering
    \footnotesize
	\begin{tabular}{cccccc}
		\toprule
        \textbf{Item} & \textbf{Aquário} & \textbf{Corredor} & \textbf{Lavanderia} & \textbf{SalaCozinha} & \textbf{Entrada} \\
        \midrule
        memória livre [bytes] &
        30278 &
        27218 &
        26990 &
        26728 &
        26237 \\
        \# (loops) &
        1251 &
        771 &
        76 &
        925 &
        1140 \\
        \# (reinícios) &
        34 &
        18 &
        35 &
        20 &
        91 \\
        \# (desconexões do Wi-Fi) &
        15 &
        26 &
        24 &
        27 &
		77 \\
		\bottomrule
    \end{tabular}
\end{table}

O aspecto de disponibilidade foi analisado a partir da média da memória disponível --- quanto maior, melhor ---, o número de loops de 1s que ocorreram em 2s ou mais --- o que indica a existência de procedimentos que estão atrasando a correta execução de rotinas periódicas, como aquelas de “\emph{keep alive}” de comunicação ---, e o número de reinícios e desconexões da rede Wi-Fi desconsiderando aqueles causados por atualizações de \emph{firmware} dos módulos.

Como o \emph{firmware} do Corredor, Lavanderia e SalaCozinha é o mesmo (\emph{basic}), conclui-se que:

\begin{itemize}
	\item A versão aquário possui mais memória disponível, um menor número de desconexões da rede Wi-Fi e número perto da média de reinícios. Contudo, possui maior ocorrência de loops de 1s maiores que 2s, indicando algum procedimento que está consumindo tempo do loop;
	\item A versão \emph{basic} possui ocorrências de desconexões, reinícios e memória livre em valores médios;
	\item A versão \emph{entrada} possui o maior número de reinícios e desconexões da rede Wi-Fi, o que já era esperado, pois é o módulo mais longe do roteador da residência, que está em outro andar;
	\item A memória livre média das versões \emph{basic} e \emph{entrada} possuem valores próximos.
\end{itemize}

\begin{table}[H]
	\caption{Análise consolidada de uso dos relés}
	\setlength\tabcolsep{1.5pt}
	\centering
	\footnotesize
	\begin{tabular}{ccccccc}
		\toprule
		\textbf{Nome} &
		\textbf{Corredor} &
		\textbf{Sabrina} &
		\textbf{Varanda} &
		\textbf{Escada} &
		\textbf{Sala} &
		\textbf{Cozinha} \\
		\midrule
		\% Ligado &
		35.08\% &
		22.91\% &
		41.62\% &
		6.89\% &
		80.06\% &
		60.99\% \\
		\# Acionamentos &
		238 &
		202 &
		516 &
		382 &
		190 &
		233 \\
		\% Botão Físico &
		11.61\% &
		87.96\% &
		54.14\% &
		13.57\% &
		26.21\% &
		20.33\% \\
		\% Web &
		21.43\% &
		2.55\% &
		14.79\% &
		1.36\% &
		44.66\% &
		40.66\% \\
		\% RF &
		37.50\% &
		9.49\% &
		0.00\% &
		0.00\% &
		29.13\% &
		39.00\% \\
		\% Auto &
		29.46\% &
		0.00\% &
		31.08\% &
		85.07\% &
		0.00\% &
		0.00\% \\
		\bottomrule
	\end{tabular}
\end{table}

Quanto ao uso dos acionamentos possíveis (botão físico presente no módulo, pelo aplicativo backup --- Web, por controle de radiofrequência --- RF e por regra automática configurada pelo usuário - Auto), número de acionamentos e porcentagem do tempo ligado, observa-se que:

\begin{itemize}
	\item As áreas comuns têm as maiores porcentagens de tempo de lâmpadas acesas, com maiores números de acionamentos pela web, nenhum acionamento por regra automática, dobro de acionamentos por RF em relação ao botão físico para a lâmpada da cozinha e números de acionamentos por RF e botão físico em valores próximos para a Sala;
	\item A escada tem o melhor uso do acionamento automático, indicando que a regra de acender a lâmpada da escada quando a porta de entrada abrir em horário noturno é bem empregada;
	\item Para a lâmpada da varanda, ainda que com um bom uso automático, cerca de metade dos acionamentos ainda ocorre por meio do botão físico;
	\item Quarto da Sabrina possui nenhum uso de acionamento automático e poucos acionamentos pela web (celular) e controle RF, indicando que o sistema não agrega muito valor;
	\item Lâmpada do corredor possui uma distribuição aproximadamente igualitária entre os acionamentos, contrariando o comportamento esperado de que as regras automáticas de acendimento de luz quando da presença detectada seriam suficientes para o controle dessa lâmpada;
	\item O uso de acionamentos pelo aplicativo (web) somente são consideráveis nas áreas comuns, provavelmente referindo-se a quando os usuários desligam as luzes da casa toda antes de dormir. Pode-se considerar que, apesar de ser um meio adequado de apresentar o funcionamento do sistema, no uso cotidiano os usuários preferem usar controles RF, acionamento manual por botão físico ou deixar uma regra para atuação automática.
\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Curva diária Santo André -- terça-feira}
	\includegraphics[width=0.8\textwidth]{diaStoAndreTerca}
	\label{fig:diaStoAndreTerca}
\end{figure}

Tomando o dia de terça-feira como exemplo dos gráficos consolidados de Santo André, observa-se que:

\begin{itemize}
	\item Há um pico de presença no corredor às 3h. Seria o horário em que os gatos da residência estão mais ativos;
	\item A curva de presença indica maiores movimentos entre 9h e 13h e entre 17h e 1h, horários em que as pessoas entram ou saem da residência;
	\item Considerando que a segmentação de usuários da entrada está em Fabio, Victor e Admin (Nair e Sabrina):
	\begin{itemize}
		\item Das 4h às 7h, Nair/Sabrina sai da casa;
		\item Das 9h às 13h, Fabio sai de casa, algumas vezes usando seu usuário, outras vezes manualmente;
		\item Às 10h, Victor sai de casa;
		\item Das 17h às 19h, Sabrina/Nair voltam para casa;
		\item Entre 19h e 22h, Victor volta para casa;
		\item Entre 21h e 23h, Fabio volta para casa;
	\end{itemize}
	\item Os picos de porta escada indicam os horários de maior entrada e saída da residência.
\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Temperatura e aquecedor -- Módulo do Aquário}
	\includegraphics[width=1.0\textwidth]{TempAquecedorAqua}
	\label{fig:TempAquecedorAqua}
\end{figure}

Considerando a curva diária e histórico do período dos sensores e atuador do aquário, observa-se que:

\begin{itemize}
	\item Às 3h da manhã, a lâmpada está acesa e aquecedor, ligado. Isso pode ter ocorrido em um dia em particular (25/11/2017, dia atípico, como observado no gráfico do período);
	\item Das 9h às 23h, há uma regra para que a lâmpada do aquário fique acesa;
	\item A temperatura é menor às 10h e das 14h às 18h. O comportamento do aquecedor é no sentido de ligar nesses períodos.

\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Consolidado Diário -- Módulo do Aquário}
	\includegraphics[width=1.0\textwidth]{AquaDia}
	\label{fig:AquaDia}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Memória e loops -- Módulo do Corredor}
	\includegraphics[width=1.0\textwidth]{MemLivreCorredor}
	\label{fig:MemLivreCorredor}
\end{figure}

Observando sua curva diária de memória livre e loops de 1s que foram executados em mais de 2s, observou-se que:

\begin{itemize}
	\item Os períodos de maior disponibilidade são das 11h às 16h, pois há maior memória livre, que é o parâmetro mais crítico para possíveis reinícios e travamentos;
	\item Os períodos de menor disponibilidade são das 21h às 22h, nos quais houve picos de loops demorados e pouquíssima memória livre.
\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Consolidado no período -- Módulo do Corredor}
	\includegraphics[width=1.0\textwidth]{periodoCorredor}
	\label{fig:periodoCorredor}
\end{figure}

São observados em verde, no gráfico acima, as atualizações de \emph{firmware} --- o que possibilita acompanhar a melhoria de disponibilidade após a implantação de novas versões --- a quantidade de reinícios e ocorrências de desconexão do Wi-Fi. Entre 24/10 e 28/10, ocorreu grande número de desconexões do Wi-Fi, indicando indisponibilidade da rede nesses dias, que causaram uma quantidade considerável de reinícios no mesmo período.

\begin{figure}[H]
	\centering
	\caption{Consolidado diário dos sensores -- Módulo do Corredor}
	\includegraphics[width=1.0\textwidth]{sensoresdiaCorredor}
	\label{fig:sensoresdiaCorredor}
\end{figure}

No gráfico acima, observa-se inatividade às 4h da manhã e entre as 14h e 16h. A temperatura possui pouca variação, assim como a umidade. Já a curva de luminosidade acompanha a de presença. Apenas das 14h às 16h, considere que há luz natural, por isso não é um valor próximo àquele apresentado de madrugada, entre 0h e 4h.

\begin{figure}[H]
	\centering
	\caption{Uso dos acionamentos no período para a lâmpada -- Módulo do Corredor}
	\includegraphics[width=1.0\textwidth]{UsoRele1periodoCorredor}
	\label{fig:UsoRele1periodoCorredor}
\end{figure}

No primeiro gráfico, observa-se a evolução do uso dos acionamentos para o relé 1 (lâmpada do corredor) no período. Observam-se dias com maiores e menores quantidades de acionamentos e a participação das regras automáticas em relação aos outros tipos de acionamento. No segundo, verifica-se que, durante o dia, os acionamentos automáticos ocorrem entre 17h e 22h. Possivelmente, podem-se aplicar regras no período das 23h às 2h.

\begin{figure}[H]
	\centering
	\caption{Uso dos acionamentos por dia para a lâmpada -- Módulo do Corredor}
	\includegraphics[width=0.8\textwidth]{UsoRele1DiaCorredor}
	\label{fig:UsoRele1DiaCorredor}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Curva diária -- Módulo de Acesso}
	\includegraphics[width=1.0\textwidth]{EntradaConsolidadoDia}
	\label{fig:EntradaConsolidadoDia}
\end{figure}

Com a curva diária de comportamento para o módulo de entrada, observa-se que:

\begin{itemize}
	\item Os horários com maior número de acionamentos pelo celular são 10h, 12h, 19h, 21h, 22h e 23h;
	\item Usuários que entram ou saem de casa às 17h não usam o celular para abrir o portão, tampouco aqueles que entram ou saem às 5h.
\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Nível da caixa d'água -- consolidado diário}
	\includegraphics[width=1.0\textwidth]{CxAguaDia}
	\label{fig:CxAguaDia}
\end{figure}

Na curva diária do módulo da caixa d’água, nota-se que:

\begin{itemize}
	\item Há maior uso de água, provavelmente para banho, nos períodos das 9h às 12h e entre 16h e 23h;
	\item Os horários em que provavelmente há menor disponibilidade de água da rua para preencher a caixa e fazer o nível voltar a ser alto são das 5h às 6h da manhã e às 11h da manhã.

\end{itemize}

Observando o gráfico a seguir, observam-se os dias em que houve falta de água  --- picos de demora para preencher a caixa de água após algum uso perceptível pelo sensor do tipo boia.

\begin{figure}[H]
	\centering
	\caption{Tempo para encher a caixa d'água -- período}
	\includegraphics[width=1.0\textwidth]{tempoPeriodocxAgua}
	\label{fig:tempoPeriodocxAgua}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Atividade da porta -- Sala de Jarinu}
	\includegraphics[width=1.0\textwidth]{AtivPortaSalaJarinu}
	\label{fig:AtivPortaSalaJarinu}
\end{figure}

Em Jarinu, um idoso com boa saúde física mora sozinho em sua residência. Ao analisar as curvas diárias de atividade da porta da sala e presença, notou-se:

\begin{itemize}
	\item Atividade de presença ente 4h e 5h da manhã, entre 10h e 12h e entre 16h e 20h.
	\item Atividade de presença maior em domingos, segundas e terças;
	\item Grande atividade da porta da sala às 10h e 14h. O pico das 10h ocorre principalmente aos domingos.
\end{itemize}

\begin{figure}[H]
	\centering
	\caption{Atividade da presença -- Sala de Jarinu}
	\includegraphics[width=1.0\textwidth]{AtivPresencaJarinu}
	\label{fig:AtivPresencaJarinu}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Consolidado no período -- Jarinu}
	\includegraphics[width=1.0\textwidth]{JarinuPeriodo}
	\label{fig:JarinuPeriodo}
\end{figure}

Ao analisar por período, pode-se verificar o aumento ou diminuição de atividade, o que pode ser um indicativo de bem-estar. Por exemplo, no gráfico acima verifica-se que o dia 04/11 foi um dia atípico, com menores níveis de presença e atividade da porta da sala.

Ainda, a partir do dia 30/11 (último movimento registrado em 29/11 às 16h20), observa-se que não há mais movimentação na residência (seria uma situação para geração de alerta). Nesse caso em específico, foi verificado que o idoso estava de fato fora de casa, através de ligação ao idoso.

É importante destacar que é possível comprovar a continuidade de funcionamento do módulo após 29/11 ao inspecionar seus próprios registros e emails enviados com informações de estado da conexão (envio periódico a cada 6 horas), como forma de mitigar um falso negativo.
\chapter{Conclusões}

A principal contribuição deste trabalho foi a criação de uma arquitetura abrangente e robusta para a automação residencial, com sua implementação completa --- desde os módulos de hardware à aplicação cliente --- provando a viabilidade de solução barata e completa para residências. O projeto permitiu o estudo minucioso das diversas partes constituintes de tal sistema, com análise cuidadosa para aspectos de escalabilidade e segurança do mesmo. Algumas futuras melhorias poderiam ser implementadas no projeto futuramente, para aumentar sua usabilidade pelos usuários, sua quantidade de funcionalidades --- de forma a agregar mais valor à solução --- além de incrementações de infra-estrutura do sistema, para que pudesse escalar com tranquilidade. Algumas dessas otimizações estão citadas abaixo.

A fim de demonstrar todas as funcionalidades dos módulos, por meio do aplicativo web, optou-se pelo modelo de \textit{dashboard}, que promove interação com fluidez e concisão. Porém, a arquitetura permite que outros tipos de aplicação possam se comunicar com as casas. O processamento de linguagem natural com um \textit{chatbot}, por exemplo, ajudaria o morador a interagir com a casa, guiando-o durante o processo de criação de regras para acionamento automático de dispositivos. A área de \textit{Business Intelligence} também oferece um vasto campo a ser explorado, com a criação de um aplicativo capaz de exibir dados da casa em gráficos parametrizados, com relatórios sobre o comportamento dos usuários. Como demonstrado na Seção \ref{coletaAnaliseDados} e Apêndice \ref{DataCollected}, são obtidas informações relevantes sobre a vida dos moradores de uma residência mesmo com um número limitado de sensores e atuadores em uso.

Para a implementação atual, não foram realizados testes de carga para o servidor na nuvem, o qual foi implementado como um monolito, em uma única instância. O próximo passo seria avaliar os melhores procedimentos de escalabilidade e estudo de sua performance com vários dispositivos e usuários conectados, de modo que seja possível a identificação de gargalos em seus componentes. Como visto na Seção \ref{servidorNaNuvem}, as tecnologias empregadas na implementação do servidor na nuvem --- nginx, Node.js, MongoDB e Redis --- possuem características favoráveis à sua utilização em aplicações altamente escaláveis.  O desafio, a partir daí, se concentraria na redundância para a comunicação com as casas, onde são utilizadas conexões WebSocket.

O monitoramento do servidor de nuvem também pode ser explorado, de maneira que sejam entendidas suas características de uso, peça essencial para o alcance de maior disponibilidade e robustez. A integração realizada durante o projeto foi simplificada e usou um serviço que apenas monitora uso de memória e CPU. Idealmente, deve ser possível também acompanhar eventos e transações importantes que ocorrem na nuvem, configurar alertas de picos de uso de recursos e poder ter uma visão consolidada dos logs, com busca e estatísticas.

Nos aspectos de hardware, e da infraestrutura de comunicação, podem ser explorados outros canais, transparentes ao usuário, e que seriam capazes de oferecer maior robustez à aplicação. Ao ampliar as formas de comunicação disponíveis, os módulos poderiam fazer uso de redes de dados --- 4G e futuramente 5G --- e não seriam mais dependentes exclusivamente da Internet local. A possibilidade de atualização de \textit{firmware} remotamente agregou em segurança e flexibilidade ao projeto, já que torna possível o envio de correções diretamente ao usuário, por meio da Internet, sem a necessidade do contato direto com o módulo. Assim, frente a uma potencial ameaça, pode-se desenvolver uma correção e enviá-la aos clientes, que manteriam suas casas atualizadas.

A integração, e também o desenvolvimento, de dispositivos vestíveis, integráveis com a casa, é também um passo futuro, que melhorará a experiência do usuário e expandirá as possibilidades de aplicação --- como, por exemplo, um relógio que monitora pessoas idosas, e envia notificações e alertas aos familiares.

Para as funcionalidades de aprendizado de máquina, o próximo passo seria a integração de tais algoritmos em um microsserviço que interaja em tempo real com o restante do sistema, de modo a trazer melhorias contínuas e otimizações ao algoritmo, aĺém de permitir que tais algoritmos passem a interagir com o usuário --- sugerindo ações a serem tomadas automaticamente pelo sistema --- ou que passem a fazer verificações que trariam mais segurança à casa.

Como outras sugestões aos próximos passos e caminhos futuros, indica-se a criação de testes unitários e automatizados, que verificam pequenas porções de código por vez. Isso facilitaria a adição de novas funcionalidades, garantindo a compatibilidade reversa, além de aumentar as chances de identificar falhas antes de liberar novas versões de software ao público. Com a mesma mentalidade, pode-se implementar uma \textit{pipeline} de integração contínua para identificar erros de integração rapidamente por meio de testes e verificação de código e permitir o lançamento de novas versões de maneira ágil. O fato do código-fonte do Hedwig já estar em um sistema de controle de versão, o GitHub, é um acelerador para o uso de serviços de integração contínua. Outro importante aspecto relacionado às tecnologias de Internet das Coisas, mas que não foi coberto neste trabalho são as questões éticas e relacionadas à privacidade do usuário, as quais são complexas e necessitarão de grandes esforços para a elaboração de uma legislação adequada.
\chapter{Arquitetura: Especificação de Negócios e de Requisitos}

\section{Partes Interessadas}
Um dos passos iniciais na elaboração de um projeto é a determinação das partes interessadas (\emph{stakeholders}). Com esse conhecimento, pode-se entender as necessidades dos diferentes perfis de clientes e as expectativas desses grupos em relação ao uso do produto. Por meio da análise de aplicação, tanto do projeto desenvolvido quanto dos dispositivos existentes, podem-se destacar os seguintes grupos dentre os potenciais consumidores:

\begin{itemize}
\item Pessoas que moram sozinhas e seus familiares, na sua maioria idosos com boa saúde física;
\item Pessoas que buscam comodidade no uso e controle de dispositivos domésticos;
\item Pessoas preocupadas com o consumo de água e energia elétrica.
\end{itemize}

Considerando o Censo de 2010 \cite{ibge}, pode-se estimar as classes de consumidores para a cidade de São Paulo:

\begin{itemize}
\item Considerando que 1/10 da população com mais de 60 anos more sozinha e que 1/4 deles adquiriria o produto, obtém-se uma estimativa de 33 mil consumidores. Como essa população está envelhecendo em taxas cada vez maiores (8,96\% em 2000 contra 13,6\% em 2016) \cite{bibliotecaVirtual}, a tendência é que essa classe aumente;
\item Considerando que 1/100 dos domicílios ocupados tenha uma pessoa com esse perfil, obtém-se uma estimativa de 35 mil consumidores em potencial;
\item Considerando que cerca de 70\% das residências reduziram o consumo com campanhas de uso de água em 2015 \cite{g1}, e supondo que 5\% desse total se interessaria em adquirir produtos que auxilia nessa redução, obtém-se uma estimativa de 71 mil consumidores em potencial.
\end{itemize}

\section{Requisitos \label{sec:requisitos}}

O levantamento de requisitos funcionais e não funcionais são definidos a seguir. Para requisitos funcionais, utilizou-se o termo \emph{RF} seguido de um número identificador --- e.g. \emph{RF-1}. Os requisitos não-funcionais levam o termo \emph{RNF}, também seguido de um identificador numérico --- e.g. \emph{RNF-1}.

\subsection{Requisitos Funcionais}
\begin{description}
\item[RF-1:]O sistema deve permitir o monitoramento de aparelhos do dia-a-dia, dentro de uma residência, de maneira independente;
\item[RF-2:]O sistema deve ser capaz de notificar o usuário sobre o estado da casa --- e.g. temperatura, presença, etc;
\item[RF-3:]O sistema deve poder ser personalizável pelo usuário, o qual pode adicionar ou remover funcionalidades;
\item[RF-4:]O sistema deve permitir o controle de dispositivos da residência;
\item[RF-5:]O sistema deve ser capaz de aprender a respeito de cada usuário, podendo detectar padrões no seu comportamento e, a partir disso, sugerir ações a serem tomadas automaticamente --- e.g. acendimento automático de lâmpadas;
\item[RF-6:]O sistema deve permitir o cadastro, remoção e atualização de usuários;
\item[RF-7:]O sistema deve permitir o cadastro, remoção e atualização de casas, para cada usuário;
\item[RF-8:]O sistema deve permitir o cadastro, remoção e atualização de dispositivos, para cada casa;
\item[RF-9:]O sistema deve permitir o seu reinício (\emph{reset});
\item[RF-10:]O sistema deve permitir a autenticação de usuários;
\item[RF-11:]O sistema deve permitir a configuração de dispositivos;
\item[RF-12:]O sistema deve disponibilizar uma API para comunicação.

\end{description}

\subsection{Requisitos Não-funcionais}
O levantamento de requisitos não-funcionais foi realizado com base na norma ISO25010:2011 \cite{iso25010}.

\begin{description}
\item[RNF-1:]Os dispositivos que compõem o sistema dentro de uma residência devem ser independentes entre si, devendo obedecer a uma interface comum de integração com o \emph{core} do projeto, para que seja facilitada a sua ampliação e extensão, com outras funcionalidades;
\item[RNF-2:]O sistema deve garantir segurança dos dados por meio de protocolos de comunicação seguros. O tráfego de informação entre as residências e os servidores externos não pode ser realizado em texto aberto. A comunicação interna da casa deve ser realizada em canais restritos;
\item[RNF-3:]Os dados de cadastro do sistema devem ser armazenados em servidores seguros \cite{softwareSecurity};
\item[RNF-4:]O sistema deve ser robusto, de modo a continuar operando, mesmo que com menor nível de funcionalidades, quando há ocorrência de falhas na comunicação entre a casa e serviços externos --- e.g. indisponibilidade parcial devido a problemas com servidores remotos, indisponibilidade total devido a perda da conexão com a Internet --- ou falhas na rede interna, como a indisponibilidade de conexão local. A validação é realizada com interrupções na rede, desconexão e desligamentos de servidores e dispositivos, seguida da verificação dos serviços disponíveis;
\item[RNF-5:]O sistema deve identificar e se recuperar de travamentos em suas partes, reiniciando-as;
\item[RNF-6:]O sistema deve possuir mecanismos de proteção contra ataques de negação de serviço (DoS);
\item[RNF-7:]O sistema deve apresentar disponibilidade de 99,9\% --- cerca de 8 horas de indisponibilidade por ano. Essa medida de disponibilidade refere-se somente aos serviços remotos, não levando em consideração indisponibilidades das residências. Esse número foi baseado nos \emph{Service Level Agreements} de soluções como a AWS\footnote{https://aws.amazon.com/ec2/sla/} e Digital Ocean \footnote{https://www.digitalocean.com/help/policy/}, que apresentam SLA maior do que essa taxa (atualmente, 99.99\%);
\item[RNF-8:]O sistema deve ser escalável a até 10 mil usuários, sem perdas de desempenho consideráveis ou aumento na latência para as requisições serem atendidas, com variação de até 5\%. A verificação deve ser realizada com softwares de análise de performance comerciais\footnote{Um exemplo de aplicação de monitoramento de rede é desenvolvida pela empresa Dynatrace \url{https://www.dynatrace.com/} };
\item[RNF-9:]O sistema deve possuir instalação intuitiva e simplificada --- a instalação é realizada em passos, seguindo o manual de instruções, sem a necessidade de conhecimentos de computação ou eletrônica;
\item[RNF-10:]O sistema deve atender e processar requisições em paralelo, tanto dos usuários quanto dos dispositivos físicos;
\item[RNF-11:]O sistema deve autenticar e autorizar as requisições recebidas, descartando as requisições inválidas.
\end{description}

\subsection{Funcionalidades por Nível de Conectividade}

Os requisitos apresentados anteriormente detalham o sistema completo. Para que o requisito RNF-4 fosse implementado, o projeto incorporou três níveis de funcionalidade --- \emph{Online}, \emph{Local} e \emph{Offline}. O primeiro nível, \emph{Online}, é o mais amplo e caracteriza o comportamento normal do sistema, quando todas as conexões estão disponíveis, e os dispositivos e serviços funcionam corretamente. O nível \emph{Local} modela o cenário de não haver possibilidade de conexão externa com a casa, como é o caso quando não há Internet disponível. O último nível, \emph{Offline}, reflete uma situação emergencial, no caso de problemas com o servidor local, por exemplo.
\chapter{Introdução}

\section{Motivação}
Há uma expectativa de que, no ano de 2017, o número de casas inteligentes aumente em aproximadamente 17\% nos Estados Unidos \cite{mckinseyReport}, onde já se tem investimentos de grandes empresas, como Google, Amazon e Apple. O interesse nessa área é tamanho que a Google investiu 5 milhões de dólares em um comercial de seu produto Google Home no Super Bowl 2017, jogo que decide o time campeão da temporada de futebol americano nos EUA \cite{kennemer}. É esperado que os consumidores invistam cada vez mais em casas inteligentes nos próximos anos, com previsões de que o valor total desse mercado chegue a mais de 63 bilhões de dólares em 2020 \cite{businessWire}.

As aplicações de automação residencial não mais se limitam aos sistemas de iluminação, controle da ventilação e temperatura de cômodos. Elas contemplam também segurança, eficiência energética e até mesmo soluções voltadas à área da saúde, com dispositivos desenvolvidos especificamente para pessoas idosas, com problemas de mobilidade ou doenças crônicas \cite{iscoop}.

Os avanços das tecnologias de Internet das Coisas (\textit{Internet of Things} ou \wiot{}) apontam para um futuro no qual qualquer dispositivo da casa possa estar conectado à Internet, onde surge uma série de possibilidades de inovações em funcionalidades e integrações. É previsto que o número de conexões \textit{Machine to Machine} (M2M) de dispositivos de casa conectada tenha uma taxa de crescimento anual composta (\emph{Compound Annual Growth Rate} ou CAGR) de 18\% entre 2016 e 2021 \cite{ciscoReport}.

\begin{figure}[H]
	\centering
	\caption{Crescimento do número de conexões M2M por tipo de aplicação}
  \includegraphics[width=1.0\textwidth]{m2mGrowth}
	\caption*{Fonte: \cite{ciscoReport}}
\label{fig:m2mGrowth}
\end{figure}

As oportunidades trazidas pelo conceito de \wiot{} à área de automação residencial são uma grande motivação para esse projeto. Também destaca-se a possibilidade de promover tais conhecimentos ao mercado nacional, com a criação de produtos e a sua adequação às necessidades dos potenciais consumidores brasileiros. Mesmo nos Estados Unidos, ainda é necessário tempo até que as casas conectadas se consolidem, de modo que há uma conjuntura propícia ao pioneirismo, com a criação de tecnologias de \wiot{} à preços acessíveis, capazes de serem absorvidos pela demanda de mercados emergentes.

\section{Projeto Hedwig}

\subsection{Objetivo}
A contribuição do projeto para o avanço das tecnologias de Internet das Coisas fundamenta-se na criação de um sistema com arquitetura modularizada, e em camadas, com funcionalidades locais e de nuvem, provendo uma API que permita seu acesso por diversos clientes --- como websites ou aplicativos para smartphones --- que seja capaz de monitorar e agir nos dispositivos presentes na residência do usuário final do sistema. O projeto disponibiliza módulos físicos, prontos para serem instalados e configurados, sem que sejam necessários conhecimentos avançados de eletrônica ou computação.

Para a elaboração do projeto, e o alinhamento das expectativas e requisitos que o motivaram, os seguintes conceitos desempenharam papéis relevantes:

\begin{description}
\item \textbf{Robustez}

Com foco na robustez e disponibilidade, são ser previstos níveis de operação para o sistema, os quais dispõem de diferentes requisitos de funcionalidades para garantir serviços essenciais, mesmo na ocorrência de problemas como a queda do servidor local, indisponibilidade de Internet, falha no roteador, dentre diversas outras possibilidades. Há medidas tratativas, nos diferentes níveis, para a tentativa automática de reconexão, monitoramento de estado e manutenções preventivas e corretivas do sistema.

\item \textbf{Modularidade}

A modularidade, principalmente relacionada aos dispositivos físicos e as decisões arquiteturais, promove a independência de funcionamento entre as partes, e contribui no atendimento aos requisitos de robustez e disponibilidade. Em relação aos dispositivos, também representa diminuição nos custos de produção, e a possibilidade de que dispositivos específicos sejam desenvolvidos para aplicações diversas.

\item \textbf{Camadas}

A arquitetura do projeto é concebida em camadas e níveis, cujas responsabilidades são independentes. Cada parte do sistema exercita um conjunto de tarefas específicas (de transporte, análise, tomada de ações, etc.), e seus efeitos são traduzidos em entradas para o nível seguinte.

\item \textbf{Aprendizado de máquina}

Geração de aprendizado de máquina por meio de análise automática do uso do sistema pelos usuários, de forma a entender suas rotinas e poder atuar no conhecimento obtido, com notificações, alertas e acionamentos automáticos de funções para o usuário.

\item \textbf{Segurança}

A proteção da privacidade do usuário é tão importante, ou talvez mais, quanto a proteção física da casa. Assim, necessita-se que o sistema seja seguro, e que o fluxo de dados trocados entre as partes ocorra em meios protegidos. Foram utilizadas protocolos criptográficos modernos para a proteção da troca de mensagens entre servidor local e serviços de nuvem. Todo usuário é autenticado e autorizado por meio de \emph{tokens}, ao utilizar o aplicativo cliente, e a comunicação interna da casa é realizada em canais restritos.

\end{description}

\subsection{Nome do Projeto}
O nome do projeto foi escolhido em homenagem a Hedy Lamarr. Nascida Hedwig Eva Maria Kiesler \cite{shearer}, a atriz e inventora desenvolveu, durante a Segunda Guerra Mundial, um aparelho de interferência em rádio para despistar radares nazistas, cujos princípios estão incorporados nas tecnologias atuais de Wi-Fi, CDMA e Bluetooth \cite{electronicFrontier}. Baseado na ideia de um sistema de comunicação seguro, e como reconhecimento de seu trabalho, foi dado esse nome ao projeto aqui descrito.

\subsection{Logo}
O logo do projeto é uma coruja, em referência à coruja Hedwig do personagem Harry Potter, da série de livros de mesmo nome. A coruja é responsável por encaminhar mensagens de maneira segura entre os interlocutores, assim como o projeto desenvolvido promove uma maneira segura de comunicação com sua casa.

\begin{figure}[H]
	\centering
	\caption{Logotipo do projeto Hedwig}
  \includegraphics[width=0.35\textwidth]{hedwigLogo}
\label{fig:hedwigLogo}
\end{figure}

\section{Aplicações}
Como aplicações do projeto Hedwig, destacam-se a automação no uso de eletrodomésticos e iluminação, segurança no acesso à casa, economia nas contas de energia elétrica, além de  monitoramento remoto de pessoas que moram sozinhas, principalmente pessoas idosas, garantindo a tranquilidade de seus familiares e mantendo a segurança do indivíduo.

Exemplos de módulos que podem ser incluídos no sistema são: quarto (despertador, iluminação, monitoramento de temperatura e umidade); cozinha (\textit{timer}, iluminação, monitoramento de presença e gás); acesso (controle de abertura, monitoramento de estado); externo (monitoramento de temperatura, umidade, energia elétrica e consumo de água); corredor (monitoramento de presença, iluminação); chuveiro (controle de temperatura\slash potência a partir do perfil de usuário e temperatura externa) e ar condicionado (controle da potência a partir do monitoramento das temperaturas internas e externas da casa).

A presença de funcionalidades de aprendizado de máquina incrementa o sistema, traz facilidades e promove maior adaptação às rotinas dos moradores. O sistema é capaz de aprender com \emph{feedbacks} do usuário, seja pelo monitoramento dos módulos ou por respostas dadas pelo aplicativo, podendo atuar em questões de segurança (\emph{safety}), personalizações e até mesmo em possíveis sugestões de produtos relacionados aos hábitos do cliente.
\chapter{Metodologia}

\section{Gerência do Projeto}

Para realizar a gerência do projeto Hedwig, foram usadas certas diretrizes do PMBOK \cite{pmi} e da norma ISO/IEC 12207 \cite{iso12207} como referência para coordenar os processos.

\subsection{Gerência de Escopo}

Segue a EAP (Estrutura Analítica do Projeto), que orientou as entregas realizadas e escopo do projeto.

\begin{figure}[H]
	\centering
	\caption{EAP do Hedwig}
	\includegraphics[width=0.8\textwidth]{Hedwig_EAP}
	\label{fig:Hedwig_EAP}
\end{figure}

\subsection{Gerência de Aquisição}

O gerenciamento de aquisições envolve primariamente a compra dos materiais necessários para implementação dos módulos físicos. Foi necessário analisar o que adquirir e como fazê-lo, levando em consideração as limitações de tempo do projeto --- a demora ou atraso na entrega dos componentes eletrônicos causaria um atraso no cronograma. A escolha dos fornecedores priorizou, então, o custo e o prazo de entrega.

A relação de materiais necessários para a confecção de um módulo básico encontra-se no Apêndice \ref{listamateriais}.

\subsection{Gerência de Processos de Software}

Para gerenciar o código-fonte e permitir o trabalho da equipe em múltiplas partes do projeto ao mesmo tempo, foi utilizado o Git, um sistema de controle de versão distribuído. Para publicação do código, foi escolhido o GitHub, onde criou-se a organização Hedwig\footnote{https://github.com/hedwig-project} e os repositórios que contém o código das diversas partes do sistema. A preferência pelo GitHub se deu pelas suas funcionalidades de gerenciamento e colaboração, como a notificação de \emph{bugs}, acompanhamento do progresso de tarefas e criação de \textit{wikis}, além de ser uma plataforma conhecida por abrigar grandes projetos \emph{open-source} que chegam a ter centenas ou milhares de contribuidores \cite{github}. O GitHub disponibiliza também uma ferramenta para armazenamento de \emph{Issues} --- atividades que necessitam ser observadas ou desenvolvidas em um projeto. Esse recurso foi essencial na organização de tarefas e rastreamento de mudanças em curso.

Para a coordenação de trabalho nesses repositórios, foi utilizado o fluxo conhecido como \textit{Feature Branch Workflow} \cite{atlassian}, caracterizado pela criação de \textit{branches} (ramificações) para o desenvolvimento de cada nova funcionalidade. Ao final do desenvolvimento de cada funcionalidade, é feito um pedido para mesclar à \textit{master branch}, ramificação principal, o código desenvolvido na ramificação atual --- conhecido como \emph{Pull Request}. A utilização de \emph{Pull Requests} promove maior controle sobre a atualização do código mantido, e também promove a revisão do código pelos aprovadores. 

Já outros tipos de documentação formal do sistema, como textos e planilhas, foram editados e armazenados no Google Drive\footnote{https://www.google.com/drive/}, ferramenta de armazenamento e backup da Google que também permite colaboração, compartilhamento e controle de versão.

\subsection{Gerência de Comunicação}

Para comunicar as tarefas, estudos e pesquisas sendo realizadas durante o projeto, foi utilizado o Trello\footnote{https://trello.com/}, um sistema online para organização de ideias e projetos, que permite listagem e acompanhamento das atividades a serem realizadas, permitindo a adição de prazos, delegação de responsáveis e categorização das tarefas.

Foram realizadas diversas reuniões online usando ferramentas de videoconferência, como o Google Hangouts\footnote{https://hangouts.google.com} e o Skype\footnote{https://www.skype.com}, que, além do \emph{streaming} de vídeo com áudio, possuem funcionalidades como mensagens de texto, envio de arquivo e compartilhamento de tela, facilitando demonstrações e testes integrados.

\subsection{Gerência de Riscos}

Para gerenciar os riscos do projeto, foram realizadas reuniões periódicas com participação das partes interessadas --- grupo e orientadores --- nas quais discutiam-se táticas de análise, planejamento e monitoramento. Nessas sessões, foi possível identificar riscos por meio da revisão da documentação e de técnicas de \emph{brainstorming} e definir estratégias de abordagem de riscos.

\section{Pesquisa Bibliográfica}

O estudo dos tópicos relacionados a aprendizagem de máquina foi realizado com auxílio do curso \emph{Aprendizagem Automática}, do Professor Andrew Ng\footnote{ https://www.coursera.org/learn/machine-learning}, oferecido pela Universidade de Stanford e disponibilizado no Coursera, uma plataforma de MOOCs (\textit{Massive Open Online Courses}) que oferece cursos abertos e especializações. O livro ``Introduction to Statistical Learning in R'' \cite{islr} também foi amnplamente utilizado para aprendizado nessa área.

Os cursos da especialização em \textit{Data Science} da Universidade Johns Hopkins\footnote{ https://www.coursera.org/specializations/jhu-data-science}, também disponíveis no Coursera, foram usados como referência e treinamento para realizar a coleta de dados de maneira metódica. Por esse motivo, foi dada maior atenção ao curso \textit{Getting and Cleaning Data}. Contudo, também foi aproveitado conteúdo do curso \textit{Practical Machine Learning}.

\section{Ferramentas e Tecnologias}

Para a aprendizagem da biblioteca React, para o desenvolvimento do \emph{front-end}, foi usada como referência a documentação oficial\footnote{https://facebook.github.io/react/docs/hello-world.html} oferecida pelo Facebook e o curso \textit{React for Beginners} de Wes Bos\footnote{ https://reactforbeginners.com/}. O aprendizado de Redux foi auxiliado pelo curso \textit{Learn Redux}\footnote{https://learnredux.com}, do mesmo autor. O conhecimento necessário à utilizaçãodo Spring Boot foi obtido com base no guia de referência oficial\footnote{https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/}.

O aprendizado para uso de outros \emph{frameworks}, ferramentas e tecnologias citadas ao longo deste documento foi altamente baseado em documentações oficiais dos mesmos disponibilizados gratuitamente em páginas na Internet, além de diversos tutoriais disponibilizados pela comunidade que utiliza tais ferramentas e tecnologias.

\section{Método de Testes}

A estratégia de testes utilizada está fortemente relacionada com a estratégia de desenvolvimento. A implementação do projeto foi realizada em partes, segregadas de acordo a área de aplicação. Assim, as diversas frentes puderam ser desenvolvidas em paralelo, como os módulos, servidor local, aplicativo cliente, etc. juntamente com os seus respectivos testes.

Para cada tarefa específica foram efetuados testes unitários, de pequeno alcance, para validar a funcionalidade ou alteração. O desenvolvimento do servidor local contou também com testes unitários automatizados, entretanto sem cobertura do sistema inteiro. Para testes específicos dos \emph{endpoints} do servidor na nuvem foi utilizada a ferramenta Postman\footnote{https://www.getpostman.com/}, que permite simular requisições a tais \emph{endpoints}, configurando todos os parâmetros necessários e informações de cabeçalho HTTP, e apresenta ao usuário a resposta recebida.

Durante a integração das partes, houveram diversos testes ponto-a-ponto, para verificação do funcionamento completo do sistema. Utilizou-se para isso o Software MQTT Fx\footnote{http://mqttfx.jensd.de/}, onde é possível obter as mensagens encaminhadas pelo sistema de mensageria, e compará-las com os resultados esperados. Na Subseção \ref{testesTopicos} são mostrados alguns casos de testes utilizados durante a configuração do Broker Mosquitto, enquanto a seção \ref{atttestefimafim} contém um exemplo de teste fim a fim realizado com aplicativo, servidor local, nuvem e módulo.

Com a instalação do sistema em duas residências distintas, houve uma validação contínua de premissas e levantamento de requisitos, principalmente aqueles relacionados à usabilidade. Foram realizados diversos testes de conceito em campo, de forma que muitas soluções, embora fizessem sentido experimentalmente em implementações isoladas, não eram adequadas para módulos instalados em uma residência real. Ainda, atualizações e melhorias foram entregues frequentemente, contribuindo para o crescimento iterativo do projeto (destacam-se a aplicação dos princípios 2 e 4 do Agile Manifesto\footnote{http://agilemanifesto.org/iso/ptbr/manifesto.html}, que dissertam sobre mudanças frequentes de requisitos e entregas frequentes de software).

Em especial, o contato do desenvolvedor dos módulos com todos os problemas e desafios encontrados com o uso do sistema em sua residência facilitou sua proximidade com um dos stakeholders principais, possibilitando um \textit{feedback} rápido, reduzindo o ciclo de desenvolvimento consideravelmente.
\chapter{Projetos Relacionados}

\section{Sistemas Existentes no Mercado}

\subsection{Sistemas Comerciais}
Atualmente, já existem sistemas comerciais de automação residencial --- a maioria deles atuando de maneira mais forte no mercado norte-americano. Alguns dos sistemas mais populares nessa linha são o Amazon Echo e o Google Home.

O Amazon Echo\footnote{http://www.amazon.com/oc/echo/} consiste em um \textit{smart speaker} (alto-falante inteligente) conectado ao assistente pessoal Alexa, também da Amazon, que é capaz de entender comandos de voz. Inicialmente, funcionava como uma maneira de encomendar produtos, mas, atualmente, além de ser assistente pessoal, também é capaz de controlar diversos \textit{smart devices} da casa, como um \textit{hub} de automação residencial. Uma limitação deste produto é dependência de conexão \textit{wireless} de Internet, não sendo capaz de operar em nenhum nível sem ela.

Uma característica interessante do Alexa é a possibilidade de adição de novas \textit{skills} (habilidades) por desenvolvedores, que possuem acesso a uma API pública, documentada e disponibilizada online. Dessa forma, seu \textit{skillset} é passível de grande expansão e personalização. Além disso, o serviço de voz desse sistema, conhecido como Alexa Voice Service, pode ser utilizado por qualquer dispositivo que contenha microfone e alto falante, e que consiga conectar-se a ele pela Internet.

O Google Home\footnote{https://madeby.google.com/home/} é similar ao Amazon Echo em alguns aspectos, sendo também um \textit{smart speaker}, que surgiu como expansão do aplicativo para smartphones Google Now, um assistente pessoal. Atualmente existe também como aplicativo para smartphones. Não é possível o desenvolvimento de módulos e expansões ao Google Home por desenvolvedores desvinculados à Google, porém ela trabalha diretamente com outras marcas e produtos para o estabelecimento de parcerias, de forma que o Google Home também consiga funcionar como \textit{hub} de automação residencial.

\subsection{Sistemas \emph{Open-source}}
Também existem diversos projetos \emph{open-source} sobre o tema, cujas documentações estão disponíveis publicamente na Internet. Alguns desses projetos, analisados para o desenvolvimento do Hedwig, foram o OpenHAB e o Home Assistant.

O OpenHAB\footnote{http://www.openhab.org/} possui como objetivo principal o estabelecimento de uma plataforma de integração, capaz de solucionar o problema atual de haver diversos dispositivos em uma residência que não são capazes de se comunicar, devido à falta de uma linguagem comum para a troca informações. Por ser independente de hardware específico, é extremamente flexível e personalizável, porém isso implica em maior complexidade para o usuário no momento de sua instalação. O OpenHAB apresenta interface para o usuário em cliente web e aplicativos nativos para iOS e Android.

O Home Assistant\footnote{https://github.com/home-assistant/home-assistant} é uma plataforma de automação residencial capaz de controlar e monitorar os diversos dispositivos em uma casa, oferecendo uma plataforma web para o controle do sistema pelo usuário. O controlador local é implementado em Python, e recomenda-se instalá-lo em um Raspberry Pi. Possui diversas integrações já estabelecidas, com sistemas e serviços como o próprio Amazon Echo, Google Cast, IFTTT, Digital Ocean, entre outros, mas possibilita também a criação de novos componentes pelos próprios usuários. A personalização pelos usuários é feita por meio de um arquivo de configuração no formato YAML.

Os dois projetos apresentam como maior dificuldade a necessidade do usuário possuir conhecimentos técnicos para utilizá-los.

\section{Projeto HomeSky}

O Projeto HomeSky \cite{homeSky} é um Trabalho de Conclusão de Curso desenvolvido por alunos de Engenharia de Computação na Escola Politécnica da Universidade de São Paulo. Com o objetivo de fomentar iniciativas de desenvolvimento na área de casas inteligentes, o trabalho focou-se na criação do Rainfall, um protocolo em código aberto a nível de aplicação para ser usado na coordenação de uma rede de sensores. Isso permitiria aos desenvolvedores ter uma maior flexibilidade em seus projetos, visto que muitas das soluções existentes são proprietárias. Por fim, também foi realizada a implementação de um algoritmo de aprendizado de máquina capaz de controlar a iluminação.

\begin{figure}[H]
	\centering
	\caption{Camadas da arquitetura usada no Projeto HomeSky. As camadas em verde correspondem às bibliotecas desenvolvidas no trabalho.}
  \includegraphics[width=0.8\textwidth]{arquiteturaHomeSky}
	\caption*{Fonte: \cite{homeSky}}
\label{fig:arquiteturaHomeSky}
\end{figure}

No desenvolvimento do protocolo Rainfall, foram consideradas algumas hipóteses simplificadoras a respeito da conectividade e da segurança. O protocolo não trata de forma especial a fase de conexão à rede, considerando que todos os nós já estão conectados a ela, e também considera que todos os protocolos adjacentes são confiáveis, delegando as implementações de mecanismos de reconhecimento de entrega e retransmissão ao desenvolvedor. Quanto à segurança, assume-se que a infraestrutura seja segura e que nenhum nó conectado à rede tenha comportamento mal-intencionado, como por exemplo espionar mensagens destinadas a outros nós ou fingir ser o controlador.
\section{Controlador Local - Morpheus \label{chap:morpheus}}

\subsection{Descrição}
Morpheus é o servidor local responsável pela interconexão da casa inteligente com os serviços de nuvem. O nome tem sua origem na mitologia grega, cujo Deus dos sonhos, Morpheus, era responsável pelo envio de mensagens entre dois mundos diferentes, o dos deuses e o dos mortais \cite{morpheusName}. A principal atribuição do servidor local é garantir que a troca de mensagem entre os módulos e a nuvem seja realizada com segurança e confiabilidade, munindo-se de soluções robustas para desempenhar o seu papel.

\subsection{Plataforma}
O Morpheus tem seu desenvolvimento realizado em Java. Conforme será detalhado em seguida, tal escolha foi realizada com base na portabilidade que a máquina virtual Java (JVM) oferece, bem como na disponibilidade de bibliotecas e serviços largamente utilizados em aplicações comerciais. O servidor foi construído utilizando-se o Spring Boot Framework.

Para se comunicar com os módulos, o Morpheus utiliza-se da conexão com um \emph{broker} \wmqtt{}. O \emph{broker} Mosquitto foi utilizado por ser uma solução \emph{open-source} largamente utilizada em projetos de \wiot. Conforme detalhado a frente, configurações de segurança específicas para o projeto foram registradas no \emph{broker}. Para a conexão com os serviços na nuvem, é utilizado um canal WebSocket aberto pelo Morpheus (cliente) e aceito pela nuvem (servidor). Esta solução veio a partir de uma discussão em relação à segurança, relativa ao requisito não-funcional RNF-6, conforme documentada na Subseção \ref{sub:websocket}.

\subsection{Tecnologias Utilizadas}
Toda a implementação do Morpheus foi realizada na linguagem Java. Desde o começo do projeto, decidiu-se que a escolha de tecnologias para implementação das diversas camadas deveria ter por base os seus benefícios, e não necessitaria ser rígida ou uniforme. Assim, o principal esforço foi sempre no planejamento das interfaces de comunicação entre as partes, que poderiam ser implementadas em linguagens complementamente diferentes. Os sistemas de nuvem, por exemplo, foram implementados em Node.js. O aplicativo web também em foi feito em JavaScript, com utilização da biblioteca React. Os módulos de hardware foram programados em linguagem \emph{C-like}, própria para Arduino, e o controlador local em Java. Essa flexibilidade permitiu a utilização de recursos e tecnologias que fossem melhor integrados com os requisitos propostos.

Um requisito essencial para o controlador local é a sua robustez (RNF-4). Em um cenário em que este controlador não esteja disponível, a casa passa a funcionar em estado de emergência, no qual os comandos são reduzidos e não permitem acesso remoto. Entretanto, há inúmeras possibilidades e eventos que poderiam causar a queda deste controlador, muitas das quais referem-se a situações fora de nosso alcance. Por exemplo, a falta de energia ou de Internet na residência interrompe o seu funcionamento, não sendo possível ter controle sobre tal situação. O mesmo ocorre no evento de problemas de hardware na plataforma que o sistema estiver rodando. Os planos para contenção dos seus efeitos de tais situações são complexos, custosos e fogem do escopo deste projeto, como seria o caso de implementar duplicações, banco de baterias e tecnologia celular para comunicação secundária.

Há, entretanto, problemas no software que poderiam afetar o funcionamento do controlador. Por meio de testes, muitos desses problemas podem ser evitados ainda em tempo de desenvolvimento. A utilização de tecnologias que facilitam o desenvolvimento seguro da aplicação é uma vantagem para este caso, já que ferramentas estão disponíveis para que haja maior controle sobre o código desenvolvido, e pode-se detectar erros mais facilmente, ainda em tempo de compilação, por exemplo.

O controlador local também precisa lidar com as requisições assincronamente, conforme o requisito não-funcional RNF-10. Parte desta tarefa é facilitada com a utilização do sistema de mensageria \wmqtt{}, operado pelo \emph{broker} Mosquitto. Com sua utilização, mensagens podem ser enviadas mesmo que o controlador não consiga recebê-las, pois elas não serão perdidas. Entretanto, devido às características do sistema proposto, as mensagens precisam ser operadas sem maiores demoras. O controlador deve receber e processar as mensagens paralelamente, e não esperar o processamento de uma mensagem inteira para processar a próxima, de modo que o paralelismo deve ser parte essencial da arquitetura.

Ainda, para a integração com os serviços da nuvem, é necessário a utilização de JSON, para a serialização das mensagens, em um formato que pode ser desserializado posteriormente, independentemente da plataforma. Para a utilização de WebSockets, é necessário o uso de bibliotecas disponíveis, de modo que o desenvolvimento seja facilitado. Por último, é necessário gerenciar eficientemente todas essas dependências. Atualizá-las quando necessário, ou substituí-las, se desejado, deve ser uma tarefa simples.

A arquitetura oferecida pelo Java mostra ser efetiva para as necessidades levantadas acima. Com a utilização de uma IDE avançada, inúmeros recursos estão disponíveis para limpeza, refatoração, organização do código, etc. É uma linguagem utilizada em vasta gama de aplicações, desde complexos softwares comerciais como a IDE Eclipse, até softwares embutidos, como controladores de BlueRay \cite{javaBlueray}. A escolha do Java 8 foi decidida para que o desenvolvimento possa utilizar certos recursos de paradigmas funcionais, como o conceito de Streams de dados e Funções Lambdas.

O \emph{framework} Spring Boot\footnote{https://projects.spring.io/spring-boot/} foi utilizado para o desenvolvimento por oferecer diversos recursos facilitadores, configurações de ambiente e um \emph{container} para inversão de controle (\emph{IoC - Inversion of Control}) e injeção de dependência. Essa técnica diminui o acoplamento entre classes e permite a evolução e implementação de novas funcionalidades de maneira fácil \cite{iocFowler}. Assim, cada módulo recebe em seu construtor todas as dependências que serão utilizadas. A responsabilidade da construção de tais dependências passa, então, a ser responsabilidade do gerenciador de contexto, e não mais do módulo.

Além disso, o gerenciador de dependências Gradle\footnote{https://gradle.org/} também foi utilizado por oferecer um poderoso ambiente para configurar, construir e distribuir aplicações. Gradle faz uso de Groovy\footnote{http://groovy-lang.org/}, tecnologia que também roda na Java Virtual Machine (JVM). Por outro lado, o uso de tais ferramentas e plataformas necessita de hardware mais robusto para que funcione, sendo uma desvantagem. Contudo, frente aos benefícios, ainda é vantajosa a utilização de Java neste caso.

Internamente, o Morpheus é dividido em pacotes, que são responsáveis pela modelagem do problema. Há classes que modelam o domínio, que executam as regras de negócio, que fazem a interface entre outros sistemas (\wmqtt{} Mosquitto Broker e nuvem), e que fazem a execução de tarefas como backup de mensagens, e serviços de conversão.
Assim que uma mensagem chega ao Morpheus, ela é reconhecida e é realizado o seu \emph{parsing} para as estruturas de domínio internas. Caso haja algum erro nas mensagens vindas da nuvem, há o envio de relatório com os problemas encontrados. A partir do reconhecimento, a mensagem é colocada em uma fila interna, onde outro módulo será responsável por capturá-la e realizar o processamento necessário.

\begin{figure}
	\centering
	\caption{Arquitetura do servidor local}
  \includegraphics[width=\textwidth]{diagramaDeComunicacao}
\label{fig:diagramaDeComunicacao}
\end{figure}

\subsection{Características e Recursos}
Para a concepção do servidor local, foram considerados os requisitos funcionais e não-funcionais, discutidos na Seção \ref{sec:requisitos}. As características e recursos da implementação são discutidos em seguida.

\begin{description}

\item \textbf{Configuração dos módulos físicos}

De acordo com as regras e interfaces estabelecidas, os módulos podem ser configurados por meio de mensagens. Os serviços da nuvem enviam os parâmetros de configuração de cada módulo ao Morpheus, que os transmitirá ao módulo.

\item \textbf{Envio de dados para a nuvem}

Dados provenientes de sensores são enviados para a nuvem, para que possam ser tratados de acordo com as regras de \emph{Business Intelligence} e utilizados em algoritmos de aprendizado de máquina.

\item \textbf{Persistência de dados}

Quando não houver conexão, o servidor armazena os dados localmente e, quando solicitado, os envia à nuvem.

\item \textbf{Tentativas de reenvio}

Quando uma mensagem não é enviada com sucesso à nuvem, o Morpheus tenta novamente por um número configurável de vezes em um curto espaço de tempo. Isso ocorre porque, se determinada mensagem não pode ser enviada em uma janela temporal, ela perde o seu sentido (e.g. requisição de abertura de portão).

\item \textbf{Verificação do \emph{timestamp}}

Quando uma nova mensagem chegar, seu \emph{timestamp} é verificado, e a mensagem tomará curso somente se não for obsoleta.

\item \textbf{Tomadas de ação}

Quando o usuário requisitar uma tomada de ação, esta deve ser enviada por meio de uma mensagem ao Morpheus, por onde será transmitida ao módulo.

\item \textbf{Configuração em arquivo}

As configurações básicas do Morpheus devem ser registradas em um arquivo YAML que é lido durante a inicialização.

\item \textbf{Listeners para diferentes tipos de mensagens}

Devem haver \emph{listeners} para todos os tipos de mensagens que são recebidos da nuvem e dos módulos.

\item \textbf{Processamento concorrente}

Toda a infraestrutura do Morpheus permite o processamento concorrente de mensagens. Não é necessário esperar o processamento completo de uma mensagem para que outra comece a ser processada.

\item \textbf{Utilização de criptografia na troca de mensagens com a nuvem}

Os dados que trafegam entre a nuvem e o servidor local são encriptados na camada de transporte por meio de \emph{TLS}.

\item \textbf{Conversão de mensagens}

As mensagens enviadas à nuvem são codificadas em JSON após serem convertidas do formato interno, que se refere apenas à troca de mensagens entre os módulos e o Morpheus.

\item \textbf{Serialização das configurações}

O servidor serializa e persiste as configurações relativas aos módulos que foram configurados para carregá-las em sua inicialização.

\item \textbf{Destruição de pools de threads}

Ao ser desligado, todos os \emph{pools} de \emph{threads} criados são destruídos.

\end{description}

\subsection{Protocolo para Troca de Mensagens com Módulos}

Toda a comunicação entre as partes do projeto é realizada por troca de mensagens. Foi desenvolvido um protocolo específico, leve e expansível, para a codificação dessas mensagens. As subseções seguintes definem e exemplificam o uso do protocolo.

\subsubsection{Tópicos}
Todos os tópicos devem seguir o formato especificado em seguida. Com essa formatação, é possível garantir que:

\begin{enumerate}
\item Somente o Morpheus consegue publicar em qualquer tópico ou ser um \emph{subscriber} de qualquer tópico.
\item Cada módulo somente consigue publicar no tópico determinado para ele, o que é garantido com as credenciais (usuário e senha) fornecidos pelo tópico.
\item Caso um módulo malicioso seja implantado com o roubo das credenciais de um módulo legítimo, o impacto será unicamente concentrado naquele tópico, não atingindo outros módulos.
\end{enumerate}

Têm-se as seguintes regras:

\textbf{hw/\textless ID do módulo\textgreater /s2m}

\emph{Server to Module} --- o módulo deve ser \emph{subscriber} desse tópico. O servidor deve ser \emph{publisher} desse tópico.

\textbf{hw/\textless ID do módulo\textgreater /m2s}

\emph{Module to Server} --- o servidor deve ser \emph{subscriber} desse tópico. O módulo deve ser \emph{publisher} desse tópico.

\subsubsection{Regras de Negócio}
O servidor foi desenvolvido com base nas regras de negócio seguintes. Cada regra de negócio tem sua identificação dada por \emph{mRN}, seguida de um identificador numérico --- e.g. \emph{mRN-1}.
\begin{description}
\item[mRN-1:]Após a compra de cada módulo, o usuário deve registrar online a aquisição. O servidor da nuvem enviará para o servidor local da casa a requisição para configurar o módulo.
\item[mRN-2:]Cada módulo envia mensagens para o servidor local com o seus dados por meio do \wmqtt{}.
\item[mRN-3:]Para a troca de senha do Wi-Fi, o usuário cadastra no aplicativo a nova senha. O servidor na nuvem faz a requisição para o servidor local, o qual enviará um arquivo de configuração com a nova senha para cada um dos módulos registrados. Após a configuração de todos os módulos, o servidor local envia resposta de sucesso para a nuvem, a qual indica ao usuário que a troca de senha já pode ser feita com sucesso.
\item[mRN-4:]Todo módulo sai de fábrica configurado com o tópico que deve se inscrever e publicar com base no seu ID, o qual será o seu usuário, também havendo uma senha para se autenticar junto ao \emph{broker} \wmqtt{}.
\end{description}

\subsubsection{Definição de Interfaces}
\begin{itemize}
\item Há três tipos de mensagens que vão do Morpheus para os módulos:
  \begin{itemize}
  \item Configuração (\texttt{configuration})
  \item Requisição de ação (\texttt{action\_request})
  \item Requisição de dados (\texttt{data\_transmission})
  \end{itemize}
\item Há três tipos de mensagens que chegam dos módulos:
  \begin{itemize}
  \item Confirmação (\texttt{confirmation})
  \item Envio de dados (\texttt{data\_transmission})
  \item Requisição de dados (\texttt{data\_request})
  \end{itemize}
\end{itemize}

\subsubsection{Definição das Mensagens}

\paragraph{Configuração (\texttt{configuration})}
\begin{itemize}
\item Sentido: Morpheus para módulo.
\item Uso: envio de parâmetros para configuração dos módulos.
\end{itemize}

\textbf{Configuração de hora}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: time_config
@
updated_ntp: <segundos desde 00h00 de 1 de Janeiro de 1970, 64 bits>
@
\end{lstlisting}

\textbf{Configuração de nome}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: name_config
@
new_name: <string do nome>
new_rele1name: <string do nome | "">
new_rele2name: <string do nome | "">
@
\end{lstlisting}

\textbf{Configuração de comunicação}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: comunication_config
@
new_ssid: <novo ssid>
new_password: <nova senha>
ip_local: <novo ip local fixo>
ap_mod: <"sempre ativo" | "automatico">
ap_name: <nome do ap para acesso direto>
ap_password: <senha do ap para acesso direto>
@
\end{lstlisting}

\textbf{Configuração de RF}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: rf_config
@
<nome do sensor | controle | funcao>: <"store" | "clear" | "keep">
@
\end{lstlisting}

\textbf{Configuração de display}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: display_config
@
displaytype: <1 | 2 | 3>
backlight: <0 | 1 | 2>
@
\end{lstlisting}
0 = desligado, 1 = ligado, 2 = automático

\paragraph{Requisição de ação (\texttt{action\_request})}
\begin{itemize}
\item Sentido: Morpheus para módulo.
\item Uso: quando um usuário faz a requisição de uma ação por meio do aplicativo. Por exemplo, quando deseja-se acender uma luz, o aplicativo envia uma requisição para o Morpheus, que enviará uma mensagem de \texttt{action\_request} para o módulo correspondente.
\end{itemize}

\textbf{Requisição de acionamento}
\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: rele1_action
@
rele1: <0 | 1>
@
\end{lstlisting}
Essa mensagem fica sem efeito no caso do Módulo de Acesso, que usa mensagens com senha para o acionamento do relé 1.

Rele1: 0 = desligar; 1 = ligar

\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: rele2_action
@
rele2: <0 | 1>
@
\end{lstlisting}
Rele2: 0 = desligar; 1 = ligar

\textbf{Requisição de reinício de software}
\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: sw_reset
@
swreset: <0 | 1>
@
\end{lstlisting}
0 = não; 1 = confirmar reinício

\textbf{Requisição de teste de \emph{auto reset}}
\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: autoreset_test
@
autoreset: <0 | 1>
@
\end{lstlisting}
0 = não; 1 = confirmar reinício

\paragraph{Confirmação (\texttt{confirmation})}
\begin{itemize}
\item Sentido: do módulo para o servidor.
\item Uso: confirmação de uma configuração ou requisição de ação vindas do servidor.
\end{itemize}

\textbf{Confirmação de hora}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: time_confirm
@
ntp: <segundos desde 00h00 de 1 de Janeiro de 1970, 64 bits>
@
\end{lstlisting}

\textbf{Confirmação de nome}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: name_confirm
@
name: <nome>
rele1name: <string do nome | "">
rele2name: <string do nome | "">
@
\end{lstlisting}

\textbf{Confirmação de comunicação}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: communication_confirm
@
ssid: <novo ssid>
password: <nova senha>
ip local: <novo ip local fixo>
ap mod: <"sempre ativo" | "automatico">
ap name: <nome do ap para acesso direto>
ap password: <senha do ap para acesso direto>
@
\end{lstlisting}

\textbf{Confirmação de configuração de RF}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: rf_confirm
@
<nome do sensor | nome do controle | nome do funcao>: <valor_gravado>
@
\end{lstlisting}

\textbf{Configuração de configuração de display}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: display_confirm
@
displaytype: <1 | 2 | 3>
backlight: <0 | 1>
@
\end{lstlisting}

\textbf{Confirmação de reinício de software}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: sw_reset_confirm
@
swreset: <0 | 1>
@
\end{lstlisting}

\textbf{Confirmação de teste de \emph{auto reset}}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: autoreset_test_confirm
@
autoreset: <0 | 1>
@
\end{lstlisting}

\paragraph{Transmissão de dados (\texttt{data\_transmission})}
\begin{itemize}
\item Sentido: do módulo para o servidor.
\item Uso: envio de dados de sensores para o servidor.
\end{itemize}

\textbf{Transmissão de umidade, temperatura, presença, relés, sensor de presença e luminosidade}
\begin{lstlisting}
#data_transmission
$ts: <timestamp>
$ty: temp_umi_pres
@
s1: umidade
vl1: <value>
s2: temperatura
vl2: <value>
s3: presenca
vl3: <value>
s4: rl1
vl4: <value>
s5: rl2
vl5: <value>
s6: abertura
vl6: <0|1>
s7: luz
vl7: <int de 0 a 1000>
@
\end{lstlisting}

\paragraph{Requisição de dados (\texttt{data\_request})}
\begin{itemize}
\item Sentido: do módulo para o servidor.
\item Protocolo: \wmqtt{}
\item Uso: requisição de alguma informação do servidor (ex.: atualização de hora).
\end{itemize}


\textbf{Mensagens próprias para o Módulo de Acesso}


\textbf{Configuração de alarme}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: alarm_config
@
alarme: <0|1>
alarme_tempo: <int do tempo em segundos>
@
\end{lstlisting}

\textbf{Configuração de luz automática}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: auto1_config
@
initial_time1: <integer de 0 a 23>
final_time1: <integer de 0 a 23>
time_keepon1: <tempo em minutos>
time_deslmanual1: <tempo em minutos>
@
\end{lstlisting}

\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: auto2_config
@
initial_time2: <integer de 0 a 23>
final_time2: <integer de 0 a 23>
time_keepon2: <tempo em minutos>
time_deslmanual2: <tempo em minutos>
@
\end{lstlisting}

\textbf{Configuração de senha}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: password_config
@
old_password: <string>
new_password: <string>
@
\end{lstlisting}

\textbf{Abertura de portão}
\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: abertura_portao
@
password: <string>
@
\end{lstlisting}

\textbf{Confirmação de alarme}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: alarm_confirm
@
alarme: <0|1>
alarme_tempo: <tempo em minutos>
@
\end{lstlisting}

\textbf{Confirmação de configuracão de luz automática}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: auto1_confirm
@
initial_time1: <integer de 0 a 23>
final_time1: <integer de 0 a 23>
time_keepon1: <tempo em minutos>
time_deslmanual1: <tempo em minutos>
@
\end{lstlisting}

\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: auto2_confirm
@
initial_time2: <integer de 0 a 23>
final_time2: <integer de 0 a 23>
time_keepon2: <tempo em minutos>
time_deslmanual2: <tempo em minutos>
@
\end{lstlisting}

\textbf{Confirmação de senha}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: password_confirm
@
password: <string>
@
\end{lstlisting}

\textbf{Transmissão de estado de acesso}
\begin{lstlisting}
#data_transmission
$ts: <timestamp>
$ty: acesso_estado
@
s1: abertura
vl: <0 fechado | 1 aberto>
s2: alarme
vl: <0 desligado | 1 ligado>
s3: tempo_alarme
vl: <value>
@
\end{lstlisting}

tempo\_alarme: tempo em minutos em que o sensor de abertura está aberto.

\textbf{Mensagens próprias para o Módulo do Quarto}

\textbf{Configuração de despertador}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: despertador_config
@
despertador: <0 | 1>
despertador_tempo: <tempo em minutos>
@
\end{lstlisting}

\textbf{Configuração de luz automática}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: acesso_config
@
initial_time: <integer de 0 a 23>
final_time: <integer de 0 a 23>
time_keepon: <tempo em minutos>
time_deslmanual: <tempo em minutos>
@
\end{lstlisting}

\textbf{Confirmação de despertador}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: despertador_config
@
despertador: <0 | 1>
despertador_tempo: <tempo em minutos>
@
\end{lstlisting}

\textbf{Confirmação de luz automática}
\begin{lstlisting}
$ts: <timestamp>
$ty: acesso_config
@
initial_time: <integer de 0 a 23>
final_time: <integer de 0 a 23>
time_keepon: <tempo em minutos>
time_deslmanual: <tempo em minutos>
\end{lstlisting}

\textbf{Mensagens próprias para o Módulo do Externo}

\textbf{Configuração de alerta de 1 (água) e 2 (energia elétrica)}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: offset_config
@
alerta1: <0 | 1>
alerta1_nivel: <vl>
alerta2: <0 | 1>
alerta2_nivel: <vl>
@
\end{lstlisting}

\textbf{Confirmação de configuração de alerta de 1 (água) e 2 (energia elétrica)}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: offset_config
@
alerta1: <0 | 1>
alerta1_nivel: <vl>
alerta2: <0 | 1>
alerta2_nivel: <vl>
@
\end{lstlisting}

\textbf{Transmissão de estado de Módulo Externo}
\begin{lstlisting}
#data_transmission
$ts: <timestamp>
$ty: externo_estado
@
s1: agua
vl: <integer>
s2: energia_eletrica
vl: <integer>
s1: agua_alerta
vl: <0 | 1>
s2: energia_eletrica_alerta
vl: <0 | 1>
@
\end{lstlisting}

\textbf{Mensagens próprias para o Módulo da Cozinha}

\textbf{Programação para preparo (café ou arroz)}
\begin{lstlisting}
#configuration
$ts: <timestamp>
$ty: offset_config
@
initialtime: <vl>
finaltime: <vl>
cooking_time: <vl>
cook_mode: <"auto" | "manual">
@
\end{lstlisting}

\textbf{Confirmação de programação para preparo (café ou arroz)}
\begin{lstlisting}
#confirmation
$ts: <timestamp>
$ty: offset_config
@
initialtime: <vl>
finaltime: <vl>
cooking_time: <vl>
cook_mode: <"auto" | "manual">
@
\end{lstlisting}

\textbf{Transmissão de estado do Módulo da Cozinha}
\begin{lstlisting}
#data_transmission
$ts: <timestamp>
$ty: cozinha_estado
@
s1: gas
vl: <integer>
s2: cooking
vl: <0 | 1>
@
\end{lstlisting}

\textbf{Requisição de offset para alarme de gás}
\begin{lstlisting}
#data_transmission
$ts: <timestamp>
$ty: gas_offset
@
<vl>
@
\end{lstlisting}

\subsubsection{Testes Realizados da Comunicação Morpheus e Módulos}

Para que fosse simulado o envio de mensagens, o aplicativo \wmqtt{} Fx\footnote{http://mqttfx.jensd.de/} foi utilizado. Com o uso deste software, é possível se inscrever em determinado tópico, enviar as credenciais para o \emph{broker}, tanto em forma de usuário e senha, quando em forma de certificados, além de publicar no tópico desejado.

\textbf{Requisição de acionamento 1}
\begin{lstlisting}
#action_request
$ts:<timestamp>
$ty: rele1_action
@
rele1: 0
@
\end{lstlisting}

\emph{Esperado: 0 no serial do Arduino, indicando recebimento.}

\emph{Resultado: de acordo.}

\textbf{Requisição de acionamento 2}
\begin{lstlisting}
#action request
$ts: <timestamp>
$ty: rele2_action
@
rele2: 1
@
\end{lstlisting}

\emph{Esperado: 1 no serial do Arduino, indicando recebimento.}

\emph{Resultado: de acordo.}

\textbf{Requisição e confirmação de reinício de software}
\begin{lstlisting}
#action_request
$ts: <timestamp>
$ty: sw_reset
@
swreset: 1
@
\end{lstlisting}

\emph{Esperado: confirmação de SW Restart no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Requisição e confirmação de teste de \emph{auto reset}}
\begin{lstlisting}
#action request
$ts: <timestamp>
$ty: autoreset_test
@
autoreset: 1
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Configuração e confirmação de hora}
\begin{lstlisting}
#configuration
$ts: 293029
$ty: time_config
@
updated_ntp: 293029
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Configuração e confirmação de nome}
\begin{lstlisting}
#configuration
$ts: 432524
$ty: name_config
@
new_name: NovoNome
new_rele1name: Portal1
new_rele2name: Portal2
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Configuração e confirmação de comunicação}
\begin{lstlisting}
#configuration
$ts: 5349545
$ty: comunication_config
@
new_ssid: Novossid
new_password: novaSenha
ip_local: 192.168.0.32
ap_mod: automatico
ap_name: AcessoDiretoAP
ap_password: 1234
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Configuração e confirmação de RF}
\begin{lstlisting}
#configuration
$ts: 4839434
$ty: rf_config
@
Janela4: 01234
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Configuração e confirmação de display}
\begin{lstlisting}
#configuration
$ts: 543242
$ty: display_config
@
displaytype: 369
backlight: 1
@
\end{lstlisting}

\emph{Esperado: confirmação no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\textbf{Transmissão de umidade, temperatura, presença e relés}
\begin{lstlisting}
messageToSend = UmiTempPresReles(0,80,25,1,1,0);
\end{lstlisting}

\emph{Esperado: mensagem no tópico \wmqtt{} m2s.}

\emph{Resultado: de acordo.}

\subsection{Protocolo para Troca de Mensagens com a Nuvem}
A troca de mensagens entre Morpheus e servidor na nuvem ocorre por meio de WebSockets. Como explicado anteriormente, caso o servidor local provesse uma API REST aberta à conexões externas, seriam necessárias configurações, software e hardware avançados para a proteção, o que seria inviável para o propósito em questão. Além disso, usuários domésticos possuem endereços IP dinâmicos, de maneira que seria necessária a atualização desse endereço na nuvem a cada mudança. Com a utilização do WebSocket, o servidor local é um cliente que solicita a abertura de uma conexão com a nuvem, que é mantida aberta a partir daí.

A comunicação com a nuvem é baseada em eventos, que são recebidos e enviados com os dados relevantes. Os eventos estão descritos a seguir.

\subsubsection{Morpheus}
O Morpheus ouve os seguintes eventos vindos da nuvem:

\begin{itemize}
\item \texttt{configuration}
\item \texttt{action}
\item \texttt{data} (requisitar informações sobre módulo, e.g. se portão está aberto ou não).
\end{itemize}

\subsubsection{Nuvem}
A nuvem ouve os seguintes eventos vindos do Morpheus:

\begin{itemize}
\item \texttt{confirmation}
\item \texttt{configuration}
\item \texttt{data}
\end{itemize}

Definição de mensagens entre Nuvem e Morpheus
\begin{lstlisting}
configuration =
{
    "configurationId": <configurationId> ,
    "timestamp": <timestamp> ,
    "morpheusConfiguration": <morpheusConfiguration> ,
    "modulesConfiguration": <modulesConfiguration>
}
\end{lstlisting}

\begin{lstlisting}
<morpheusConfiguration>  =
{
    "register": [<eachModuleRegistration> ],
    "requestSendingPersistedMessages": <true | false>
}
\end{lstlisting}

\begin{lstlisting}
<eachModuleRegistration>  =
{
    "moduleId": <moduleId> ,
    "moduleName": <moduleName> ,
    "moduleTopic": <moduleTopic> ,
    "receiveMessagesAtMostEvery": <time> ,
    "qos": <qosLevel>
 }
 \end{lstlisting}


\textbf{Requisitos}

O campo receiveMessagesAtMostEvery deve estar no formato“\textless time\textgreater :\textless unit\textgreater ”
A unidade deve ser “s” para segundos, “m” para minutos ou “h” para horas. O valor padrão é 60 segundos.

Ex.: requisição de mensagens persistidas e configuração do Morpheus.

\textbf{Configuração de módulo}

A seção de configuração de módulo é um objeto com duas partes. A primeira identifica o módulo dentro do Morpheus, e a segunda envia as mensagens que serão interpretadas pelo módulo.
\begin{lstlisting}
{
    "moduleId": <moduleId> ,
    "moduleName": <moduleName> ,
    "moduleTopic": <moduleTopic> ,
    "unregister": <true|false>,
    "messages": [<message>]
}
\end{lstlisting}

\begin{lstlisting}
<message> =
"controlParameters":
{
    "parameter": <name> ,
    "value": <value>
},
"payload": {
    [
        <key>: <value>
    ]
}
\end{lstlisting}

\textbf{Requisição de ação}
As mensagens de \texttt{action} seguem o mesmo protocolo estabelecido anteriormente para mensagens de \texttt{action\_request}.

\textbf{Transmissão de dados}
As mensagens de \texttt{data} também seguem o mesmo protocolo estabelecido anteriormente para mensagens de \texttt{data\_transmission}.

\textbf{Exemplo de mensagem}
A seguir, um exemplo de uma mensagem completa de configuração.

\begin{lstlisting}
{
    "configurationId": "1",
    "timestamp": "1499717103422",
    "morpheusConfiguration": {},
    "modulesConfiguration": [
        {
            "moduleId": "00765914",
            "moduleName": "teste_wemos",
            "moduleTopic": "hw/00765914",
            "unregister": true
    	},
    	{
            "moduleId": "000281D0",
            "moduleName": "hugo_basic",
            "moduleTopic": "hw/000281D0",
            "unregister": false,
            "messages": [
                {
                    "controlParameters": [
                        {
                            "parameter": "ts",
                            "value": 1500914158
                        },{
                            "parameter": "ty",
                            "value": "rele1_action"
                        }
                    ],
                    "payload": {
                        "v1": 5,
                        "v2": "auto"
                    }
                }
            ]
    	}
    ]
}
\end{lstlisting}

\subsection{Configurações}

\subsubsection{Configuração do Mosquitto}

Em situações reais, cada casa terá uma instância do \emph{broker} Mosquitto rodando independente de todas as outras e aceitando somente conexões locais. Entretanto, para que fossem realizados testes e simulações, a instalação e execução de uma instância em cada máquina diferente, localmente, seria inviável. Para tanto, foram realizadas instalações em uma máquina remota --- em servidor da Digital Ocean\footnote{https://www.digitalocean.com/} --- com configurações diferentes, uma para cada residência simulada. São executadas instâncias como processos \emph{daemon} vinculados a portas diferentes --- a partir da porta 8883 (conexão com criptografia) para Morpheus e 1883 para módulos. Também foi criado um script em \emph{bash} para iniciar o processo e ativar as portas no \emph{firewall}. São necessárias as seguintes configurações para a máquina remota \cite{MQTTSecurity} \cite{PubSub}:

\begin{enumerate}
\item Habilitar a restrição de tópicos na instância \cite{topicRestriction}. A restrição deve levar em conta as credenciais do dispositivo logado no momento para definição do formato dos tópicos.

\item Os tópicos que finalizam em \emph{s2m} devem ser exclusivamente restritos ao Morpheus. Nenhum outro dispositivo deve conseguir publicar nestes tópicos. O Morpheus pode publicar e ouvir todos os tópicos.

\item Os tópicos que finalizam em \emph{m2s} são exclusivos de cada módulo. O \emph{broker} saberá se um módulo pode se inscrever ou publicar no tópico de acordo com o seu número serial.

\item Para cada casa, os módulos devem se conectar a partir da porta 1883 (e.g. primeira casa \textrightarrow{} 1883; segunda casa \textrightarrow{} 1884). Essas portas não exigem criptografia, mas devem exigir usuário e senha (que estarão vulneráveis).

\item O Morpheus é obrigado a se conectar a partir da porta 8883 (e.g. primeira casa \textrightarrow{} 8883; segunda casa \textrightarrow{} 8884), passando suas credenciais encriptadas.
\end{enumerate}

\subsubsection{Guia de Instalação}\label{sec:arquivosCriados}
O passo-a-passo descrito aqui foi testado em um ambiente Ubuntu 16.10 x64.

\begin{enumerate}
\item Utilizar o terminal para fornecer os seguintes comandos.

\lstinline{sudo apt-get update}

\lstinline{sudo apt-get install mosquitto mosquitto-clients}

\lstinline{sudo systemctl enable mosquitto}

\item Criar pastas para cada casa em \lstinline{/etc/mosquitto/conf.d} com os nomes \texttt{home\textless Número\textgreater}. Devem-se criar os arquivos \texttt{acl\_list}, \texttt{m\_home\_\textless Número\textgreater .conf}, \texttt{passwd}. O conteúdo de cada um desses arquivos é mostrado abaixo (relativos à casa de número 1).


\textbf{acl\_list}

\begin{lstlisting}[language=bash]
    # General section

    # User specific section
    ## Morpheus
    user adf654wae84fea5d8ea6
    topic readwrite hw/#

    # Client section

    ## Modules can write only to the topic with their username in the m2s version
    pattern write hw/%u/m2s

    ## Modules can only read to the topic with their username in the s2m version
    pattern read hw/%u/s2m
\end{lstlisting}

\textbf{m\_home\_1.conf}

\begin{lstlisting}[language=bash]
    password_file /etc/mosquitto/conf.d/home1/passwd
    allow_anonymous false
    acl_file /etc/mosquitto/conf.d/home1/acl_list

    # General Listener
    # When running in production, this should bind to localhost
    port 1883
    require_certificate false
    use_username_as_clientid true

    # Morpheus Listener
    # When running in production, this should bind to localhost
    listener 8883
    cafile /etc/mosquitto/ca_certificates/ca.crt
    keyfile /etc/mosquitto/certs/mosquitto.key
    certfile /etc/mosquitto/certs/mosquitto.crt
    require_certificate true
\end{lstlisting}

\textbf{passwd}

\begin{lstlisting}[language=bash]
    0002D3D7:135876
    01344682:374028
    000750A1:524708
    001A1B07:321115
    0014BB3E:147203
    asd561asd5asd984faee:852456987
\end{lstlisting}

\item Para execução do script, basta utilizar o comando seguinte na pasta onde o arquivo se localiza.

\lstinline{. start.sh}

O conteúdo do script é mostrado no Apêndice \ref{att:script}.
\end{enumerate}

\subsubsection{Criação dos Certificados}

Por fim, devem-se criar certificados válidos tanto para o \emph{broker} Mosquitto, quanto para as instâncias do Morpheus. Neste projeto, os certificados são gerados e auto-assinados. Entretanto, em um ambiente de produção, deve haver uma autoridade certificadora independente para garantia da validade e segurança.

\begin{enumerate}
\item
Criação da autoridade certificadora (chave e certificado). Para a versão atual, a senha é \texttt{hedwig123}.

\lstinline{openssl req -new -x509 -extensions v3\_ca -keyout ca.key -out ca.crt}
\item
Criação de chave e certificado para o Mosquitto. O \emph{common name} deve ser o IP do servidor.

\begin{lstlisting}[language=bash]
openssl genrsa -out mosquitto.key 2048
openssl req -new -key mosquitto.key -out mosquitto.csr
openssl x509 -req -in mosquitto.csr -CA ../ca.crt -CAkey ../ca.key -CAcreateserial -out mosquitto.crt -days 3650 -sha256
\end{lstlisting}

\item
Criação de chave e certificado para o Morpheus. O \emph{common name} deve ser \texttt{localhost}.

\begin{lstlisting}[language=bash]
openssl genrsa -out morpheus.key 2048
openssl req -new -key morpheus.key -out morpheus.csr
openssl x509 -req -in morpheus.csr -CA ../ca.crt -CAkey ../ca.key -CAcreateserial -out morpheus.crt -days 3650 -sha256 -addtrust clientAuth
openssl x509 -in morpheus.crt -outform der -out morpheus.der
\end{lstlisting}
\end{enumerate}

\subsubsection{Senhas}

Conforme mostrado anteriormente no guia de instalação (item \ref{sec:arquivosCriados}), o arquivo de senha deve ser criado no formato \lstinline{usuario:senha}. Deve-se, então, rodar o seguinte comando para que a senha não fique exposta em formato de texto:

\begin{lstlisting}
  sudo mosquitto_passwd -U passwd
\end{lstlisting}

\subsubsection{Casos de Teste para Controle de Acesso nos Tópicos \wmqtt{} entre Módulos e Nuvem \label{testesTopicos}}
\begin{enumerate}
\item
Conectar na porta 1883 sem usuário e senha.

Esperado: falha de conexão.

Resultado: bem-sucedido.
\item Conectar na porta 1883 com usuário e senha corretos.

Esperado: permissão de conexão.

Resultado: bem-sucedido.
\item
Conectar com credenciais corretas e tentar publicar em tópico que não pertence ao seu usuário.

Esperado: não-publicação.

Resultado: bem-sucedido.
\item
Conectar com credenciais corretas e tentar publicar em tópico que pertence ao seu usuário.

Esperado: publicação.

Resultado: bem-sucedido.
\item
Conectar com credenciais corretas e tentar ouvir um tópico que não pertence ao seu usuário.

Esperado: não receber dados.

Resultado: bem-sucedido.
\item
Conectar com credenciais corretas e tentar ouvir um tópico que pertence ao seu usuário.

Esperado: receber dados.

Resultado: bem-sucedido.

\item
Conectar com credenciais referentes ao Morpheus e tentar publicar ou ouvir qualquer tópico começando com \texttt{hw}.

Esperado: publicação ou subscrição com sucesso.

Resultado: bem-sucedido.
\end{enumerate}
\section{Servidor na Nuvem \label{servidorNaNuvem}}

\subsection{Descrição}

O servidor na nuvem é composto por um servidor WebSocket para comunicação entre clientes e casas, um banco de dados em memória para armazenar informações sobre conexões WebSocket ativas, uma API REST para acesso aos dados persistidos, um banco de dados não-relacional para armazenar dados dos sensores, módulos, Morpheus e usuários, um proxy reverso e um \emph{firewall}.

Para fins de prova de conceito, optou-se por prosseguir com uma arquitetura monolítica. A implementação da arquitetura de microsserviços aumentaria consideravelmente a complexidade do projeto, e seus principais benefícios não seriam tão bem aproveitados, visto que o sistema não seria colocado a provas de carga real no momento. Contudo, ressalta-se que o monolito que compõe o servidor na nuvem poderia sim ser implementado como um conjunto de microsserviços, o que seria uma evolução natural à medida que o sistema escala.

\subsection{Características da Implementação}

Com base nos requisitos funcionais e não-funcionais, discutidos na Subseção \ref{sec:requisitos}, foi realizada a implementação na nuvem. Suas características são discutidas em seguida.

\begin{description}

\item \textbf{Comunicação}

\begin{itemize}
\item O servidor permite que Morpheus e aplicativos clientes se comuniquem via WebSocket.
\item Morpheus pode enviar as mensagens provenientes dos módulos físicos, que são: \texttt{configuration}, \texttt{confirmation} e \texttt{data}. Também podem receber mensagens destinadas aos módulos físicos, que são: \texttt{action}, \texttt{configuration} e \texttt{data}.
\item Morpheus pode receber mensagens de registro e remoção de módulo para definir quais dispositivos ele gerencia.
\item Morpheus pode enviar mensagens de \texttt{report}.
\item Os aplicativos cliente podem enviar as mensagens correspondentes a interações do usuário, que são: \texttt{action} e \texttt{configuration}. Também podem receber mensagens provenientes dos módulos físicos, que são: \texttt{confirmation} e \texttt{data}.
\item Aplicativos cliente podem receber mensagens de \texttt{report}.
\item Aplicativos cliente podem receber o status de conectividade dos Morpheus e receber notificações quando um Morpheus for desconectado.
\end{itemize}

\item \textbf{Persistência de Dados}

\begin{itemize}
\item O servidor persiste dados de usuário, de configurações de Morpheus e módulo e de mensagens de dados (\texttt{data} e \texttt{report}).
\end{itemize}

\item \textbf{Gerenciamento de Dados}

\begin{itemize}
\item O servidor oferece uma API REST para leitura e escrita de dados de usuário, configurações de Morpheus e de módulos.
\end{itemize}

\item \textbf{Conexões}

\begin{itemize}
\item O servidor permite o estabelecimento de conexões HTTPS seguras e criptografadas.
\item O \emph{firewall} bloqueia conexões em portas que não estão sendo utilizadas.
\end{itemize}

\end{description}

\subsection{Tecnologias Utilizadas}

O servidor foi desenvolvido usando Node.js\footnote{https://nodejs.org}, um ambiente em tempo de execução para código em JavaScript. Sua arquitetura usa um modelo orientado a eventos e realiza a execução de comandos concorrentemente sem bloquear o servidor. Assim, servidores em Node.js conseguem alcançar uma melhor escalabilidade, suportando múltiplas conexões simultâneas sem impactos de performance.

Para a persistência de dados, foi escolhido o MongoDB\footnote{https://www.mongodb.com/}, banco de dados não-relacional baseado em documentos. A facilidade de integração com JavaScript e Node.js, a similaridade dos documentos com objetos JSON e a natureza dos dados de sensores foram as motivações para sua escolha como banco de dados principal.

Contudo, não são apenas informações sobre usuários e dispositivos e dados coletados pelos sensores que precisam ser armazenados. Para gerenciar quais Morpheus estão conectados à nuvem e a quais aplicativos suas informações em tempo real devem ser enviadas, é usado o Redis\footnote{https://redis.io/}, banco de dados em memória. Redis é popularmente usado para fins como cache, mensageria e implementação de filas. No caso do Hedwig, ele é utilizado para armazenar informações de sessão, que são temporárias e requerem baixas latências para leitura e escrita.

Para implementar a comunicação entre aplicativos e casas, foi escolhida a biblioteca Socket.io\footnote{https://socket.io/}, que fornece uma API de alto nível para troca de informações bidirecional por meio de eventos. Além de abstrair a API de baixo nível do protocolo de WebSockets, o Socket.io já fornece eventos referentes ao status da conexão, facilitando o disparo de notificações caso o controlador de uma casa seja desconectado, e implementa um \emph{fallback} para clientes que não suportam o protocolo de WebSocket. Por exemplo, se um usuário acessa um aplicativo por meio de um navegador antigo, a troca de dados continua sendo feita por meio de \emph{long polling}.

A arquitetura possui um proxy reverso que é responsável por enviar as requisições ao servidor em Node.js. Para isso, foi usado o nginx\footnote{https://nginx.org/}, popularmente utilizado como servidor HTTP e proxy genérico para TCP e UDP. Ele permite a configuração de conexões seguras via HTTPS e dispensa a necessidade de delegar privilégios para acessar as portas reservadas 80 e 443 ao processo que roda o servidor Node.js.

Por fim, foi usada a ferramenta padrão do Ubuntu para \emph{firewall}, ufw, que permite criar regras para bloquear tráfego IPv4 e IPv6.

As tecnologias apresentadas aqui favorecem a escalabilidade do sistema. O Node.js possui um modo de execução \emph{cluster}, no qual processos filhos ou \emph{workers} são criados a partir de um processo pai ou \emph{master} por meio de \emph{forking}, sendo possível assim aproveitar todas as CPUs de uma máquina \cite{nodejscluster}. O MongoDB suporta técnicas de \emph{sharding}, que é um método para distribuir dados em múltiplas máquinas para armazenar grandes quantidades de dados e garantir alta vazão de leituras e escritas \cite{mongodbsharding}. O Redis também pode ser escalado por meio de ``clusterização''. Já o nginx possui uma arquitetura que consegue lidar com centenas de milhares de requisições sem bloquear sua máquina de estados, otimizando o número de processos para diminuir o tempo gasto em mudanças de contexto \cite{nginxscalability}.

\begin{figure}[H]
	\centering
	\caption{Componentes e implementação na nuvem}
  \includegraphics[width=0.5\textwidth]{componentesNuvem}
\label{fig:componentesNuvem}
\end{figure}

\subsection{Tratamento de Eventos}

O servidor na nuvem possui uma arquitetura baseada em eventos, que transmitem dados, ações, configurações e confirmações e podem ser provenientes dos Morpheus ou dos aplicativos clientes conectados. O servidor também pode emitir seus próprios eventos para tais entidades conectadas ouvirem. Nessa seção, as rotinas de tratamento para cada tipo de evento são sucintamente descritas.

\paragraph{Conexão (\texttt{connection})}
\begin{itemize}
\item \textbf{Descrição}: um novo dispositivo se conecta à nuvem.
\item \textbf{Emitido por}: Morpheus, aplicativos clientes.
\item \textbf{Tratamento}: é criada uma \emph{string} única de identificação para a nova conexão.
\end{itemize}

\paragraph{Identificação de Dispositivo Conectado (\texttt{hello})}
\begin{itemize}
\item \textbf{Descrição}: ao se conectar à nuvem, um novo dispositivo se identifica como Morpheus ou aplicativo cliente. Em ambos os casos, é enviado também a identificação serial do Morpheus --- no caso dos aplicativos, seria o Morpheus do qual se deseja receber notificações em tempo real. Caso um aplicativo queira receber notificações de múltiplos Morpheus, devem ser enviados múltiplos eventos de \texttt{hello}.
\item \textbf{Emitido por}: Morpheus, aplicativos clientes.
\item \textbf{Tratamento}: o identificadores de conexão, os tipos de dispositivos e os identificadores seriais do Morpheus são salvos no Redis. Assim, é possível buscar qual é a conexão correspondente a cada dispositivo conectado.
Além disso, se já existem dados salvos no Redis a respeito de aplicativos ou Morpheus que referenciam ao mesmo serial de Morpheus, são enviados a eles eventos de \texttt{hello}. Um caso de uso para tal funcionalidade é a possibilidade de aplicativos saberem se todos os controladores locais de uma residência estão online.
\end{itemize}

\paragraph{Ação (\texttt{action})}
\begin{itemize}
\item \textbf{Descrição}: é enviada uma requisição de ação a um módulo.
\item \textbf{Emitido por}: aplicativos clientes.
\item \textbf{Tratamento}: é verificado se o Morpheus responsável por repassar essa requisição ao módulo físico está conectado. Se sim, o evento de \texttt{action} é re-emitido somente a ele.
\end{itemize}

\paragraph{Configuração (\texttt{configuration})}
\begin{itemize}
\item \textbf{Descrição}: é enviada uma requisição de configuração a um módulo.
\item \textbf{Emitido por}: aplicativos clientes.
\item \textbf{Tratamento}: é verificado se o Morpheus responsável por repassar essa requisição ao módulo físico está conectado. Se sim, o evento de \texttt{configuration} é re-emitido somente a ele.
\end{itemize}

\paragraph{Confirmação (\texttt{confirmation})}
\begin{itemize}
\item \textbf{Descrição}: é enviada uma confirmação de ação ou configuração a um aplicativo.
\item \textbf{Emitido por}: Morpheus.
\item \textbf{Tratamento}: é verificado se existem aplicativos correspondentes a esse Morpheus conectados à nuvem. Se sim, o evento de \texttt{confirmation} é re-emitido a todos eles. Isso é uma simplificação que obriga os aplicativos a tratarem o recebimento desse tipo de evento por si mesmos.
\end{itemize}

\paragraph{Dados (\texttt{data})}
\begin{itemize}
\item \textbf{Descrição}: é enviada uma atualização do estado do módulo físico e seus sensores.
\item \textbf{Emitido por}: Morpheus.
\item \textbf{Tratamento}: é verificado se existem aplicativos correspondentes a esse Morpheus conectados à nuvem. Se sim, o evento de \texttt{data} é re-emitido a todos eles. Além disso, esses dados são persistidos no MongoDB.
\end{itemize}

\paragraph{Relatório (\texttt{report})}
\begin{itemize}
\item \textbf{Descrição}: é enviada um relatório de configurações do Morpheus.
\item \textbf{Emitido por}: Morpheus.
\item \textbf{Tratamento}: é verificado se existem aplicativos correspondentes a esse Morpheus conectados à nuvem. Se sim, o evento de \texttt{report} é re-emitido a todos eles. Além disso, esses dados são persistidos no MongoDB.
\end{itemize}

\paragraph{Desconexão (\texttt{disconnect})}
\begin{itemize}
\item \textbf{Descrição}: um dispositivo se desconecta da nuvem.
\item \textbf{Emitido por}: Morpheus, aplicativos clientes.
\item \textbf{Tratamento}: as entradas no Redis relacionada a essa conexão são deletadas. Se o dispositivo que se desconectou foi um Morpheus, é emitido um evento de \texttt{bye} a todos os aplicativos conectados que estavam ouvindo atualizações desse Morpheus. Dessa forma, podem ser implementadas mensagens de erro e avisos ao usuário.
\end{itemize}

\subsection{Infraestrutura}

Para hospedar o servidor do Hedwig, foi utilizado o serviço de computação na nuvem Digital Ocean \footnote{https://www.digitalocean.com/}. Com ele, foi possível implantar o servidor em uma instância que roda Ubuntu 16.04.3 x64, com única CPU, 512MB de memória, 20GB de armazenamento de disco SSD e 1000GB de cota disponível para transferência de dados. O data center que hospeda essa instância fica em Nova Iorque.

\subsection{Segurança}

O servidor na nuvem suporta conexões HTTPS, permitindo que navegadores verifiquem a autenticidade do servidor e garantindo a privacidade e integridade dos dados transmitidos. Para isso, foi usado o Let's Encrypt\footnote{https://letsencrypt.org}, uma autoridade de certificação aberta, gratuita e automatizada. O Let's Encrypt usa o protocolo ACME (\emph{Automatic Certificate Management Environment}) para automatizar a comunicação entre autoridade e candidato para assegurar a autenticidade deste e conceder-lhe certificados de forma rápida e prática. É realizado um teste para verificar que o candidato possui controle sobre o domínio e, então, é gerado um certificado válido por 90 dias que pode ser renovado a qualquer momento. Para usá-lo no servidor, basta acrescentar novas configurações ao nginx.

Além disso, outra medida de segurança foi usar o \emph{firewall} ufw para bloquear conexões nas portas TCP que não estão sendo usadas.

\subsection{Operação}

O serviço Keymetrics\footnote{https://keymetrics.io/} permite verificar se o servidor na nuvem está online, monitorar o uso de CPU e de memória, investigar a ocorrência de erros e realizar ações comuns, como reiniciar o processo do servidor, por meio de uma interface amigável. Investir em um sistema de monitoramento como esse auxilia tanto a manutenção preventiva como a corretiva, o que é essencial para um sistema de casa inteligente que tem a disponibilidade como requisito prioritário.

\begin{figure}[H]
	\centering
	\caption{Monitoramento do servidor na nuvem}
  \includegraphics[width=1.0\textwidth]{keymetrics}
\label{fig:keymetrics}
\end{figure}

Outro ponto abordado é o uso de logs, arquivos que gravam eventos relevantes que acontecem no sistema. Eles podem ser usados para realizar a auditoria de falhas ocorridas e compreender melhor o funcionamento de um programa. Por questões de simplicidade, para classificar os eventos, o servidor na nuvem do Hedwig usa três dos sete níveis de severidade definidos pelo padrão syslog \cite{rfc5424}: \emph{error}, \emph{warning} e \emph{informational}. O servidor implementa um esquema de rotação de logs, criando arquivos individuais para cada dia, o que facilita o arquivamento de logs muito antigos e a pesquisa de eventos específicos. Com esse sistema, também é possível filtrar eventos de severidades diferentes em arquivos separados.
\section{Aplicativo Backup}

Para lidar com o caso de indisponibilidade do controlador local Morpheus, da rede local (roteador \emph{wireless}) ou da conexão com a Internet, foi desenvolvido um aplicativo de \textit{backup}. Esse aplicativo permite acesso direto ao módulo através do endereço local (supondo que o dispositivo celular esteja na mesma rede) ou por conexão direta com o ponto de acesso do módulo (disponível todo o tempo ou sempre que o módulo não consiga conexão com a Internet, a depender da preferência do usuário).

\subsection{Requisitos}

Destacam-se os requisitos mais críticos do aplicativo backup:

\begin{enumerate}
	\item Permitir acesso direto ao módulo em caso de indisponibilidade da rede Wi-Fi e Internet;
	\item Permitir a visualização de estado de sensores e a atuação em tempo próximo ao apresentado por botão físico;
	\item Acesso ao módulo por meio de endereço local no caso de haver rede local disponível, mas sem acesso à Internet;
	\item Possibilitar ao usuário configurar rede Wi-Fi, nome do módulo, cor do painel, offset de sensores, nome dos relés e regras de atuação (por radiofrequência, com senha ou não, por horário, por eventos dos sensores de presença e abertura, além do tempo em que deve ficar ligado no caso de configurações automáticas);
	\item Permitir configurar múltiplos códigos RF (radiofrequência) para sensor de abertura, atuação do relé 1 ou do relé 2;
	\item Permitir ao usuário configurar controle de acesso e senha para atuação de um relé em específico;
	\item Segregar permissões entre administrador e usuário --- usuários não podem executar configurações, somente visualizar estados e atuar em relés sem senha;
	\item Permitir visualização de vários módulos da residência;
	\item Ter interface de fácil navegação, intuitiva.
\end{enumerate}

\subsection{Tecnologias Utilizadas}

Para o desenvolvimento do aplicativo backup, foram utilizados:

\begin{enumerate}
	\item Módulo como servidor, utilizando bibliotecas de comunicação próprias do ESP8266 no caso de comunicação direta com o módulo, e uso do módulo como cliente, usando a mesma biblioteca;
	\item Uso de \emph{ping} para verificação de conexões e execução de rotinas para a correta configuração de estado do ponto de acesso (ligado se não conectado à rede), rotinas de desconexão e reconexão;
	\item CSS para a implementação de interface amigável para o usuário, e segregação de configurações em níveis de navegação maiores para que configurações mais usadas sejam mais facilmente acessíveis a partir do menu principal do módulo;
	\item JavaScript para as rotinas de configuração e atualização do estado no menu principal;
	\item HTML5 para o desenvolvimento da maioria das páginas;
	\item EEPROM do módulo ESP8266, onde todas configurações de conexão, gerais e relés ficam armazenadas. Em caso de mudança desses parâmetros, ocorre sua persistência na EEPROM;
	\item Bibliotecas próprias para interface com sensores e outros periféricos (DHT e I2C, por exemplo), comunicação em geral, além do Wi-Fi e \emph{Access Point} (PubSub para comunicação por MQTT).
\end{enumerate}

\subsection{Navegação}

A partir da tela inicial, um cliente pode verificar todos os módulos presentes em sua casa, visualizar temperatura, umidade, luminosidade, sensores de presença ou abertura e apagar ou acender luzes (para atuadores protegidos com senha, o usuário deve acessar a página do respectivo módulo), numa interface configurável (o usuário pode configurar quais parâmetros observar nesse menu principal). A tela da Figura \ref{fig:telasPrincipaisBackup} é própria para celulares, enquanto a tela da Figura \ref{fig:plantaBackup}, com posicionamento configurável e que simula a planta de uma casa (em um cenário real, poderia ser a própria planta da casa do usuário) é própria para desktops.

\begin{figure}[H]
	\centering
	\caption{Telas principais do Aplicativo Backup}
  \includegraphics[width=0.5\textwidth]{telasPrincipaisBackup}
\label{fig:telasPrincipaisBackup}
\end{figure}

\begin{figure}[H]
  \centering
  \caption{Visão geral da planta de uma casa com o Aplicativo Backup}
  \includegraphics[width=0.8\textwidth]{plantaBackup}
  \label{fig:plantaBackup}
\end{figure}

A partir do menu principal, pode-se acessar o menu do módulo desejado (vide Figura \ref{fig:menuPrincipalBackup}). Nele, encontram-se informações de luminosidade, horário, data, temperatura, umidade, sensor de presença (sensor 1) e sensor de abertura (sensor 2), além de controle de portão, lâmpada ou eletrodoméstico. Também exibe o nível de recepção de Wi-Fi do módulo e a versão do \emph{firmware}.

\begin{figure}[hbp]
    \centering
    \begin{minipage}{.4\linewidth}
        \centering
        \captionof{figure}{Menu principal do Aplicativo Backup}
        \includegraphics[height=6cm]{menuPrincipalBackup}
        \label{fig:menuPrincipalBackup}
    \end{minipage}
    \hfill
    \begin{minipage}{.4\linewidth}
        \centering
        \captionof{figure}{Teclado para digitação da senha}
        \includegraphics[height=6cm]{senhaBackup}
        \label{fig:senhaBackup}
    \end{minipage}
\end{figure}

No caso de proteção de controle por senha, é exibido o painel numérico como na Figura \ref{fig:senhaBackup}. A cada requisição da página, o módulo manda um mapeamento das teclas diferente. Por exemplo, as teclas A e B mapeiam para (3,1) e (9,2). Após o usuário entrar com a senha (sequência de teclas do tipo A, B, C, etc.), o módulo valida a sequência e autoriza o acionamento. Dessa forma, pessoas não conseguem copiar a senha ao visualizar a sequência de teclas do usuário, tampouco um invasor poderia copiar a sequência e utilizá-la para abertura logo em seguida, pois o mapeamento seria outro.

\subsection{Configurações}

A partir no menu principal do módulo, pode-se ter acesso ao seu log para depuração, uma opção disponível apenas para administradores, e um menu de configurações. Do menu de configurações, pode-se alterar o modo do display (dentre 3 opções) e as cores do módulo, conforme opções anteriormente citadas.

Ainda do menu de configurações, podem-se configurar alertas e alarmes (sonoros a partir dos módulos e pela Internet através do provedor gratuito Blynk e email), relés (possibilidade de auto ligar a partir de um sensor específico ou de ser acionado a partir de um sinal de rádio --- usualmente um controle remoto ou até um sensor de abertura adicional ou mais de uma opação) e o log (quais parâmetros são persistidos e mandados para a nuvem). Também pode-se acessar o menu de Ferramentas, no qual é possível realizar testes de \emph{auto reset} para verificação do funcionamento do circuito antitravamento, que age em cerca de 30 segundos, reiniciar o módulo, desconectá-lo, voltar à versão de fábrica (versão implementada em software, enquanto a versão em hardware é realizada por meio de botão oculto) e atualizar o \emph{firmware} (apenas disponível para administradores).
Ao acessar a atualização de \emph{firmware}, escolhe-se a o arquivo que contém a nova versão, para que seja feito \emph{upload} do mesmo, e o módulo seja atualizado.

É possível também acessar as configurações avançadas (vide Figura \ref{fig:firmwareconfigavancadasDHT}). Nela, pode-se configurar um offset para temperatura e umidade, de preferência realizados a partir de um medidor confiável para calibração.

Do menu de configurações avançadas, podem ser configurados os sensores e controladores de radiofrequência (sem fio), aspectos de conectividade do servidor gratuito Blynk (usado no envio de emails) e possivelmente trocar a rede Wi-Fi em que o módulo está conectado. Ainda, para administradores, há a opção de configurar os usuários que têm acesso ao módulo.

Ainda pode-se trocar o nome do módulo e ativar/desativar o ponto de acesso (para acesso direto ao módulo), além de configurar o nome (SSID) e senha de sua rede Wi-Fi.

Demais ilustrações referentes às configurações do aplicativo backup estão disponíveis no Apêndice \ref{attachmentsImagensBackup}{}.

\subsection{Abertura de Porta do Roteador}

Para acessar o módulo e o menu remotamente, uma solução é usar a abertura de porta (mecanismo NAT ou \emph{virtual servers}), configurável nas páginas de configuração dos roteadores. Maiores informações para essa configuração podem ser encontradas nos manuais dos roteadores. Observe que há uma segurança menor envolvida com essa configuração. Assim, essa alternativa provê a abertura da porta para acesso remoto sem a necessidade de serviços em nuvem, o que é indicado apenas para usuários que podem lidar com um nível de segurança mais baixo.

\begin{figure}[H]
    \centering
    \caption{Página de configuração TP Link}
    \includegraphics[width=0.8\textwidth]{tpLinkAppBackup}
    \label{fig:tpLinkAppBackup}
\end{figure}

\emph{Observação:} Caso sua operadora só forneça o CGNAT, a abertura de porta por parte do usuário não será possível.

\subsection{Controle Remoto}

Para que o controle remoto seja corretamente configurado, são necessários os seguintes passos:
\begin{enumerate}
    \item
    A partir da página inicial do módulo, entre em \# \textrightarrow{} Configurações Avançadas \textrightarrow{} RF433.

    \item
    Configure o Sensor de Abertura “Sulton” no modo 2 para mandar sinais diferentes de abertura e fechamento. Consulte o manual do fabricante.

    \item
    Aperte +, espere até a página indicar “Aguardando” e abra o sensor de abertura. É permitido incluir diversos sinais para o controle do mesmo relé, abertura ou fechamento de sensor. Aperte “OK” no canto superior direito da página, para salvar suas configurações.

    \item
    Repita o passo 3 para o fechamento do sensor de abertura. \textbf{Cuidado:} o sensor de abertura repete algumas vezes o mesmo sinal. Aguarde alguns instantes entre gravar a abertura e o fechamento para não gravar o mesmo sinal. Isso pode ser verificado na série numérica que aparece gravada: se estiver igual, há um problema.

    \item
        \begin{enumerate}
            \item
            A partir da página inicial do módulo, entre em \# \textrightarrow{} Configurações Avançadas \textrightarrow{} RF433.

            \item
            Aperte + (ao lado do relé 1 ou relé 2), espere até a página indicar “Aguardando” e abra o sensor de abertura. É permitido incluir diversos sinais para o controle do mesmo relé, abertura ou fechamento de sensor).

            \item
            Aperte ``OK'' no canto superior direito da página para salvar suas configurações.

        \end{enumerate}
\end{enumerate}

\subsection{Notificações}
Para que as notificações sejam ativadas, siga os próximos passos.

\begin{enumerate}
    \item
    Para que seja possível o envio de emails de alerta, acesse \# \textrightarrow{} Configurações Avançadas.\textrightarrow{} Blynk.

    \item
    Insira o \emph{Auth Token} (e.g. aa7a6dc1170640f08e951ed8cd2198a1).

    \item
    Selecione Notificações ao iniciar: Sim, e Wi-Fi: Sim.

    \item
    Aperte em OK, no canto superior direito, para salvar suas alterações.
\end{enumerate}

\subsection{Offset de Temperatura e Umidade}

\begin{enumerate}
    \item
    Para calibração do módulo, acesse \# \textrightarrow{} Configurações Avançadas.\textrightarrow{} Temperatura e Umidade.

    \item
    Efetue a calibração do equipamento usando uma referência externa.

    \item
    Aperte em OK, no canto superior direito, para salvar suas alterações.
\end{enumerate}

\subsection{\emph{Hard Reset}}
\begin{enumerate}
	\item Ligue na tomada
	\item Abra a tampa do módulo, e retire o isopor que cobre o sensor de temperatura azul;
	\item Localize o botão (“\emph{pushbutton}”), após retirar o isopor;
	\item Pressione o botão até ouvir 6 bipes;
	\item O módulo retornará para a configuração de fábrica. Veja as seções a seguir para sua configuração inicial.
\end{enumerate}

\subsection{Setup Inicial}
\begin{enumerate}
	\item Primeiro, conecte à rede Wi-Fi do Módulo, com nome CONFIG (a senha da rede CONFIG é 12345678).
	\item Abra um navegador e vá ao endereço 192.168.4.1 para entrar na página de configuração. Entre com as credenciais (login: admin e senha: 1234).
	\item Espere até que as redes disponíveis apareçam, selecione a rede de sua casa e forneça sua senha para conectar o módulo à Internet.
	\item Observe o endereço local 192.168.0.X que aparecerá no LCD do módulo. Caso não consiga ver, realize o passo 7 e use uma ferramenta como o “Zentri” (aplicativo Android) para descobrir em que endereço o módulo entrou. Para ver na tela novamente, pode-se tirar o módulo da tomada e ligá-lo novamente.
	\item Espere o módulo reiniciar (continue na rede CONFIG) e aguarde até a página recarregar. Insira o nome do módulo e depois aperte “Salvar e Reiniciar”.
	\item Conecte-se novamente na rede Wi-Fi da sua casa.
	\item Entre no endereço 192.168.0.X que foi mostrado no módulo, clique em \# e então em “Reiniciar Busca”. Aguarde até que todos os módulos sejam descobertos.
	\item Retorne para a página anterior (usando o “\textless” no canto superior esquerdo). Você verá o menu principal da casa, e então poderá controlar relés, visualizar dados coletados pelos módulos e acessar cada módulo. O menu é personalizado na página anterior (ao pressionar o “\#” no canto superior direito da tela).
\end{enumerate}
\section{Aplicativo de \textit{dashboard}}

\subsection{Descrição}
O aplicativo desenvolvido é uma \textit{dashboard} que permite ao morador da casa ver os dados dos sensores em tempo real, enviar requisições para os módulos realizarem alguma ação, receber confirmações de que essas ações foram realizadas e gerenciar seus dispositivos --- Morpheus e módulos. Essa \textit{dashboard} foi implementada com base nas características dos PWAs apresentadas no capítulo \ref{archweb}, relativo a arquitetura a fim de permitir uma boa experiência de usuário tanto em smartphones como em computadores.

\subsection{Requisitos}

\subsubsection{Requisitos Funcionais}
\begin{description}

\item \textbf{Realizar cadastro, login e gerenciamento de informações pessoais}

\begin{itemize}
\item O usuário pode se cadastrar com seu email, nome e data de nascimento, criando também um nome de usuário e senha para acessar a \textit{dashboard}.
\item O usuário pode realizar login usando seu nome de usuário e senha.
\item O usuário pode alterar as informações pessoais de seu cadastro.
\end{itemize}

\item \textbf{Gerenciar Morpheus}

\begin{itemize}
\item O usuário pode adicionar e remover controladores locais --- Morpheus, sendo que para o cadastro basta adicionar o número de série do dispositivo.
\item O usuário pode configurar o Morpheus, especificando se deseja que mensagens que não puderam ser enviadas por problemas de conectividade sejam mandadas assim que a conexão for reestabelecida.
\end{itemize}

\item \textbf{Gerenciar módulos}

\begin{itemize}
\item O usuário pode adicionar e remover módulos, sendo que para o cadastro deve-se adicionar o número de série do dispositivo, relacioná-lo ao Morpheus que ouvirá suas mensagens, dar um nome ao módulo e seus relés e especificar o seu tipo.
\item O usuário pode configurar o módulo, especificando as configurações de conectividade, display e teste de \emph{auto reset}.
\end{itemize}

\item \textbf{Receber dados e enviar ações em tempo real}

\begin{itemize}
\item O usuário pode visualizar em tempo real os dados dos sensores de abertura, presença, temperatura, umidade e luminosidade do módulo básico.
\item O usuário pode visualizar o estado dos relés e enviar ações para ligá-los e desligá-los.
\item O usuário pode visualizar em tempo real os dados do estado do portão e do alarme do módulo de acesso.
\item O usuário pode, no módulo de acesso, enviar uma ação para abrir o portão usando uma senha.
\end{itemize}

\item \textbf{Alterar configurações avançadas dos módulos}

\begin{itemize}
\item O usuário pode receber confirmações de que ações sensíveis foram recebidas pelos módulos corretamente.
\item O usuário pode gerenciar sensor e controle de radiofrequência.
\item O usuário pode enviar uma ação para sincronizar a hora do módulo.
\item O usuário pode enviar uma ação para reiniciar o módulo (\textit{soft reset}).
\end{itemize}

\item \textbf{Visualizar estado das conexões}

\begin{itemize}
\item O usuário pode ver o \textit{status} de sua conexão com o servidor da nuvem e da conexão de seus Morpheus com a nuvem.
\end{itemize}

\end{description}

\subsubsection{Requisitos Não-funcionais}

\begin{itemize}
\item O aplicativo deve ser responsivo e totalmente funcional nos navegadores mais recentes em suas versões desktop e mobile.
\end{itemize}

\subsection{Tecnologias Utilizadas}

Para criar a aplicação web que demonstra a funcionamento do Hedwig, foi escolhido o React\footnote{https://reactjs.org/}, biblioteca \emph{open-source} de JavaScript mantida pelo Facebook. O React é conhecido por facilitar o desenvolvimento de aplicações \textit{single-page}, renderizadas do lado do cliente, que permitem a atualização dinâmica da página de forma fluida e rápida, o que acaba enriquecendo a experiência do usuário. Possui uma linguagem declarativa e baseada em componentes, tornando-a altamente modularizável e reutilizável. Uma de suas características mais reconhecidas é o uso de um DOM virtual e um algoritmo de reconciliação que consegue identificar quais as partes da página que precisam ser renderizadas a cada interação com o usuário \cite{reactdiff}, melhorando a performance e permitindo maior fluidez em animações e mudanças visuais.

Outro ponto interessante para a utilização do React é que, com a biblioteca React Native\footnote{https://facebook.github.io/react-native/} --- uma extensão do React --- é possível a geração de aplicativos nativos para iOS e Android. Assim, caso surja a necessidade de implementar uma nova funcionalidade que possua algum requisito que não pode ser contemplado por um \textit{Progressive Web App}, mas pode ser atendido por um aplicativo nativo, pode-se usar o React Native. Isso diminui a necessidade de retrabalho e dispensa a necessidade de estudo aprofundado das linguagens e ambientes de desenvolvimento tradicionais de aplicativos nativos.

A fim de facilitar a implementação das interações com o usuário, é usada juntamente ao React a biblioteca Redux\footnote{https://redux.js.org/}, um gerenciador de estado global. Dessa forma, o compartilhamento de informações entres diferentes componentes fica simplificado. A motivação por trás do Redux é facilitar a leitura e atualização do estado da aplicação, que, em sites \textit{single-page} modernos, pode armazenar respostas do servidor, cache de dados e dados criados localmente que ainda não foram persistidos no servidor. O Redux é baseado em três princípios \cite{redux}:

\begin{itemize}
\item O estado é o ponto único de verdade.
\item O estado permite apenas a leitura --- a única forma de alterá-lo é emitindo uma \textit{action}.
\item Alterações no estado devem ser feitas por funções puras --- são os chamados \textit{reducers}, que recebem o estado anterior e uma \textit{action} e retornam o novo estado.
\end{itemize}

\begin{figure}
	\centering
	\caption{Diagrama de funcionamento do Redux}
  \includegraphics[width=\textwidth]{reduxFlowchart}
  \caption*{Fonte: \cite{reduxdataflow}}
\label{fig:reduxFlowchart}
\end{figure}

Para receber dados dos módulos em tempo real, foi usado um cliente do socket.io, \textit{framework} que já foi discutido na seção do servidor na nuvem. O cliente de JavaScript já permite monitorar o \textit{status} da conexão do aplicativo com o servidor, emitindo eventos em caso de desconexão ou reconexão. Assim, foi necessário criar \textit{listeners} para os eventos customizados que foram criados para os protocolos do Hedwig.

Uma das vantagens em usar JavaScript para criar a \emph{view} da aplicação é sua versatilidade, visto que é uma linguagem multi-paradigmas que suporta programação imperativa, declarativa e orientada a objetos \cite{mdnjs}. Outro ponto é que ela é usada tanto para desenvolvimento \emph{front-end} como \emph{back-end}, permitindo que o conhecimento acumulado na execução de um projeto ajude no outro.

Para aproveitar as funcionalidades e facilidades sintáticas das especificações mais recentes de JavaScript, é usado Babel\footnote{https://babeljs.io/}, um compilador capaz de converter as sintaxes novas e substituir as funções ainda não suportadas pelos navegadores com auxílio de \textit{polyfills}. Muitas vezes, é usado o termo transpilador para referir-se ao Babel, visto que é um compilador de JavaScript para JavaScript, não deixando de emitir como saída uma linguagem de alto-nível. Assim, é possível usar ES6 --- a versão mais recente de JavaScript --- sem se preocupar com a compatibilidade do aplicativo com os navegadores que ainda não implementaram essa especificação completamente.

Para agilizar o desenvolvimento e prevenir falhas, é tirado proveito do \textit{linter} dedicado a JavaScript ESLint\footnote{https://eslint.org/}. \textit{Linter} é uma ferramenta para verificar o código e identificar erros de programação ou inconsistências de estilo \cite{linter}, o que possibilita produzir programas mais consistentes e menos suscetíveis a bugs.

Por fim, a \emph{pipeline} de desenvolvimento do cliente usa o Webpack\footnote{https://webpack.js.org} como \textit{module bundler}. O Webpack cria gráficos de dependência de todos os componentes da aplicação web --- imagens, folhas de estilo, scripts --- e então os processa transformando-nos em \textit{bundles} ou pacotes, que nada mais são que arquivos estáticos.

\subsection{Interface}

\subsubsection{Identidade Visual}

Para facilitar o desenvolvimento, foram usados os componentes do Material Design\footnote{https://material.io/} da Google, que satisfazem várias necessidades básicas e casos de uso da criação de interfaces modernas. Para distinguir cada tipo de módulo, foram usados ícones e paletas de cores distintas.

\subsubsection{Telas}

A seguir, estão as telas principais do aplicativo mostrando os dados e as opções de ação e configuração de um Módulo de Acesso e de um Módulo Básico.

\begin{figure}[H]
	\centering
	\caption{Tela correspondente ao Módulo de Acesso}
  \includegraphics[width=1.0\textwidth]{dashboard1}
\label{fig:dashboard1}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Tela correspondente ao Módulo Básico}
  \includegraphics[width=1.0\textwidth]{dashboard2}
\label{fig:dashboard2}
\end{figure}

Demais telas do aplicativo mostrando tanto a versão desktop como a móvel podem ser encontradas no Apêndice \ref{attachmentsDashboardTelas}.

\subsection{Interações}

\subsubsection{Dados}

Dados provenientes dos sensores dos módulos são atualizados em tempo real por meio de eventos do socket.io. Para situar o usuário, o instante de tempo em que a mensagem do módulo foi enviada fica visível no fim na página. Caso seja detectado que a conexão com o Morpheus se perdeu, isso é mostrado pela \textit{dashboard} a fim de evitar que o usuário olhe dados antigos demais.

\subsubsection{Ações}

Ao enviar uma ação, o estado local do aplicativo não muda até que seja recebida uma nova mensagem de dados ou de confirmação. Isto é, se um relé está ligado e o usuário pede para desligá-lo, o aplicativo só vai mostrar que o relé desligou quando o módulo o avisa disso. Isso evita que o aplicativo entre em estados inconsistentes com os módulos.

\subsubsection{Conectividade}

O aplicativo possui um indicador no canto superior direito indicando o \textit{status} da conexão. Ele pode assumir três estados:

\begin{itemize}
\item Aplicativos e todos os Morpheus do usuário estão devidamente conectados ao servidor na nuvem.
\item Aplicativo está devidamente conectado ao servidor na nuvem, mas pelo menos um dos Morpheus não.
\item Aplicativo não está conectado ao servidor na nuvem.
\end{itemize}

Além disso, caso o aplicativo perca conexão com a nuvem, são emitidas notificações na parte inferior da tela. São realizadas 10 tentativas de reconexão e o resultado --- positivo ou não --- também aparece como um alerta na tela. Caso não haja sucesso em nenhuma das 10 tentativas, o usuário é aconselhado a atualizar a página.

\subsubsection{Aplicativo na Tela Inicial do Dispositivo Móvel}

Usando um arquivo de manifesto, foi possível configurar como o aplicativo aparece na tela inicial de um dispositivo móvel como um smartphone. Diminuir o número de passos para o usuário acessar o aplicativo o encoraja a usá-lo mais vezes, além de criar uma sensação parecida com a de um aplicativo nativo.

\subsection{Implantação}

O aplicativo foi publicado com o serviço Surge\footnote{https://surge.sh/}, que permite a hospedagem de websites estáticos e oferece um domínio customizado. O Surge possui uma aplicação de linha de comando que permite a publicação de um diretório de arquivos HTML, CSS e JavaScript de maneira rápida e sem extensiva configuração. A \textit{dashboard} está disponível em \url{https://hedwig.surge.sh}.

\subsection{Segurança}

O Surge usa a comunicação via HTTPS por padrão, oferecendo o suporte básico a TLS. Dessa forma, os dados transmitidos entre navegador e servidor podem ser criptografados, permitindo uma maior segurança em operações como cadastro, login e recebimento dos dados dos sensores.

\subsection{Performance}

Levando em consideração que o aplicativo pode ser acessado pelo celular em situações em que a qualidade da conexão não é a ideal, a otimização da \textit{dashboard} para obter uma boa performance e baixos tempos de carregamento torna-se um ponto importante. Para isso, algumas medidas foram tomadas:

\begin{itemize}
\item Arquivos estáticos são servidos por uma CDN e podem ser armazenados no cache do navegador, medida que diminui o tempo de carregamento nas visitas subsequentes à \textit{dashboard}.
\item Arquivos são compactados em formato \texttt{gzip} antes de serem enviados ao cliente, o que diminui seu tempo de download.
\item Arquivos HTML, CSS e JavaScript são minificados, diminuindo consideravelmente seu tamanho.
\item As imagens são redimensionadas e otimizadas, diminuindo consideravelmente seu tamanho.
\item Não há redirecionamentos desnecessários.
\end{itemize}
\section{Módulos}
\subsection {Rotinas}
\subsubsection{Multiplexação no Tempo}
Para tratar indisponibilidade dos módulos devido a tentativas de reconexão e conexão e requisições não-gerenciadas, e, assim, aumentar a disponibilidade, existem além do circuito antitravamento e \textit{hard reset} diversas rotinas de tratamento. Elas contemplam desde configuração inicial, reconfigurações, coletas de dados e atuação por meio de relés até conexão, desconexão, reconexão e envio de dados. Elas foram multiplexadas no tempo da seguinte forma:

\begin{figure} [H]
	\centering
	\caption{Rotina de multiplexação de procedimentos no tempo}
  \includegraphics[width=0.8\textwidth]{rotinaMultiplexacao}
\label{fig:rotinaMultiplexacao}
\end{figure}

\subsubsection{Tratamento de Indisponibilidade}
Nos casos de indisponibilidade de Internet, servidor ou rede local, o seguinte procedimento foi adotado (observe que a indisponibilidade do próprio módulo é tratada pelo circuito antitravamento):

\begin{figure}[H]
	\centering
	\caption{Tratamento de indisponibilidade de recursos}
  \includegraphics[width=0.8\textwidth]{tratamentoIndisponibilidade}
\label{fig:tratamentoIndisponibilidade}
\end{figure}

Com esse procedimento, as tentativas de reconexão à Internet, servidor e rede local estão segregadas e com tentativas realizadas em intervalos de tempo sucessivamente maiores. Desta forma, conseguimos gerenciar esses procedimentos, já que a capacidade de processamento é baixa.

\subsubsection{DoS Local (\textit{Evil Twin})}
No caso de ataque de \textit{Evil Twin} --- no qual uma rede mal-intencionada, usualmente aberta, usa o mesmo SSID da rede original com o objetivo de obter a senha --- o sistema pode ficar indisponível até ao nível local. Módulos podem se conectar à rede mal-intencionada e ficarem somente com as funcionalidades offline, como acionamento de lâmpada por botão físico acoplado ao módulo. Outro problema é a queda da rede por interferência de radiofrequência ou outro mecanismo utilizado pelo usuário mal-intencionado para que os clientes se desconectem, tentem reconexão e forneçam a senha da rede.

Além do problema de indisponibilidade, no caso do dispositivo ser capturado pela rede mal-intencionada e ser controlado por usuários não legítimos, há a possibilidade dos módulos serem usados para um ataque de DDoS \cite{OVHDDoS}.

Para mitigar esses riscos, os módulos executam o seguinte procedimento:

\begin{figure}[H]
	\centering
	\caption{Tratamento de ataque de DoS Local}
  \includegraphics[width=0.8\textwidth]{tratamentoDoS}
\label{fig:tratamentoDoS}
\end{figure}

\subsubsection{Comunicação por MQTT}
Para o desenvolvimento da comunicação por MQTT com o Morpheus no módulo, foi usada a biblioteca PubSub \cite{PubSub} para Arduino.

Para cada módulo existem identificador e senha, que são parâmetros próprios que vêm de fábrica, além de configurações de porta e endereço do Morpheus local padrões.

O controle de comunicação foi realizado da seguinte forma:

\begin{enumerate}
	\item Só há tentativa de conexão MQTT em caso de haver conexão do Wi-Fi e o horário interno estar configurado --- caso contrário, pode-se provocar travamento do módulo ou envio de mensagens sem \emph{timestamp}.
	\item É executada configuração de \emph{callback} e de servidor MQTT a cada reconexão -- este ponto foi crítico para o bom funcionamento da comunicação.
	\item No \emph{callback} ocorre recebimento de mensagens e tratamento (\emph{parsing} da mensagem recebida, o que é feito por meio de obtenção de seu tipo e redirecionamento para rotinas específicas para obtenção dos parâmetros de interesse de cada mensagem).
	\item Envio de mensagens de estado a cada um minuto ou quando houver mudança brusca em um dos sensores (presença, abertura, umidade ou temperatura) ou então requisição de atuação; nesses casos de envio rápido, a mensagem é inserida no início da fila de saída e enviada logo em seguida, em até um segundo.
	\item Após o tratamento inicial das mensagens e a obtenção dos parâmetros de interesse, ocorre a persistência nas variáveis internas e gravação da EEPROM para que configurações e estados executados no aplicativo backup ou pela dashboard sejam refletidos dos dois lados, tornando transparente ao usuário o uso de qualquer um dos aplicativos e integrando suas funcionalidades.
	\item Ainda em fase final, após a persistência de variáveis na EEPROM, ocorre a inclusão na fila de saída de mensagens de confirmação para o servidor local.
	\item A fila de saída é usada para o envio periódico das mensagens de estado.
\end{enumerate}

\begin{figure}[H]
	\centering
	\caption{Exemplo de estado da fila de saída de mensagens MQTT do módulo}
	\includegraphics[width=0.5\textwidth]{filasaidaMQTT}
	\label{fig:filasaidaMQTT}
\end{figure}

Mensagens de estado periódicas (azuis) são inseridas no final da fila. No caso de acionamento, uma mensagem de estado (vermelha) é inserida no início da fila, e, em caso de configuração, uma mensagem de confirmação também é inserida no início da fila.

Por fim, vale destacar a necessidade de alteração da biblioteca PubSub \cite{PubSub} para suportar mensagens maiores. Em caso de impossibilidade de envio de mensagens maiores, todo o protocolo deveria ser alterado para comportar mensagens mais compactas ou então deveria haver o uso de algum mecanismo de codificação ou compactação em conjunto com o protocolo desenvolvido.

\subsection{Diagrama PCB}
Abaixo está o diagrama do circuito impresso (PCB).

\begin{figure}[H]
	\centering
	\caption{Diagrama PCB do Módulo Base}
  \includegraphics[width=0.8\textwidth]{diagramaModuloBase}
\label{fig:diagramaModuloBase}
\end{figure}

\begin{enumerate}
\item Wemos D1 mini
\item Astável 555
\item Fonte 5V 3W
\item \textit{Buzzer}
\item Relé 1
\item Relé 2
\item \emph{Hard reset}
\item Botões
\item Presença
\item RF-RX
\item RF-TX
\end{enumerate}

\begin{figure}[H]
	\centering
	\caption{Diagrama elétrico do Módulo Base}
  \includegraphics[width=0.8\textwidth]{esquematicoModuloBase}
\label{fig:esquematicoModuloBase}
\end{figure}

\begin{description}
\item [A - Saídas] Circuitos simples de transistor para acionamento de relés (para lâmpadas) e \emph{buzzer}.
\item [B - Proteção 3V3 5V] Como o display trabalha com tensão de 5V, há proteções com diodos para não danificar as entradas digitais do Wemos D1 mini, que trabalha com tensão de 3V3.
\item [C - 3 Entradas em A0] O circuito tem como entradas um botão (para acionamento do relé 1), o LDR (para chaveamento da luz de fundo do display) e um outro botão para \emph{hard reset} do dispositivo, todos em uma entrada analógica, cujo mapeamento E/S é da seguinte forma:

\begin{figure}[H]
	\centering
	\caption{Entradas em A0}
  \includegraphics[width=0.4\textwidth]{entradasEmA0}
\label{fig:entradasEmA0}
\end{figure}

\item [D - Presença ou RF-TX] A entrada digital D6 é usada exclusivamente como entrada do sensor de presença PIR ou receptor RF.
\item [E - Astável 555 para \emph{hard reset} e Botão] A porta D6 é usada como LED \textit{keep alive} do módulo. Sua demora ao piscar indica que o módulo está travado ou demorando muito para processar algo, o que não deveria acontecer, uma vez que os procedimentos estão multiplexados no tempo de acordo com seus tempos limite. Dessa forma, essa saída está conectada a um circuito antitravamento, que executa o \emph{reset} nos casos mencionados, de travamento ou \textit{timeout}.

O primeiro capacitor tem como objetivo desacoplamento DC, de forma que a entrada do circuito envolvendo o astável 555 seja somente AC. Assim, permanências em 0 ou 1 indicam travamento.

Enquanto o LED pisca em intervalos esperados regularmente, o transistor conduz e mantém uma saída dente de serra muito próxima de 0. Quando o módulo trava, o transistor não conduz mais, e a saída passa a oscilar entre 1/3 e 2/3 da tensão total. Observe que o carregamento é feito pelo resistor de 4M7, muito maior que o resistor de 100k, fazendo com que o tempo de carga seja muito maior que o tempo de descarga, uma vez que esses tempos são diretamente proporcionais à constante de tempo dos circuitos RC, que é dada pelo produto do R*C. Durante a descarga, o \emph{reset} da placa é realizado. Observe que os tempos foram ajustados pelos valores dos componentes discretos, para que o tempo entre \emph{resets} sucessivos seja menor que o tempo necessário para o módulo voltar a funcionar após um \emph{reset}.

Segue abaixo uma ilustração sobre o funcionamento do circuito.

\begin{figure}[H]
	\centering
	\caption{Funcionamento do circuito antitravamento}
  \includegraphics[width=0.8\textwidth]{circuitoAntiTravamento}
\label{fig:circuitoAntiTravamento}
\end{figure}

\item [F - DHT11] Entrada D3 é ligada a uma montagem básica para leitura de umidade e temperatura através do periférico DHT11.

\end{description}

\subsection {Montagem}

As fotos e comentários seguintes descrevem o processo de montagem física dos quatro módulos usados neste trabalho. Além destes, outras versões também foram construídas anteriormente no decorrer do projeto, instaladas na residência de um dos membros do grupo e usados para coleta de dados. Tais versões, por se tratarem de protótipos, não têm sua montagem completamente documentada, tampouco a uniformidade apresentada nos módulos seguintes.
Ao final, também consta o procedimento utilizado para validação dos módulos após sua construção, que contribuiu para a identificação de ligações não realizadas e outros problemas de montagem.

\begin{figure}[H]
	\centering
	\caption{Evolução do hardware (de fevereiro/17 a setembro/17)}
	\includegraphics[width=0.8\textwidth]{evolHW}
	\label{fig:evolHW}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Evolução da caixa de proteção e display}
	\includegraphics[width=0.8\textwidth]{evolProtDisplay}
	\label{fig:evolProtDisplay}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Materiais e preparação da placa padrão}
	\includegraphics[width=0.8\textwidth]{materiaisPrepPlaca}
	\label{fig:materiaisPrepPlaca}
\end{figure}

\begin{enumerate}
	\item Primeiramente, a partir do esquemático em escala real, foram cortados e realizados furos na placa padrão.

	\begin{figure}[H]
		\centering
		\caption{Posicionamento dos componentes}
		\includegraphics[width=0.8\textwidth]{PosicionamentoComp}
		\label{fig:PosicionamentoComp}
	\end{figure}

	\item Em seguida, foram posicionados os componentes.

	\begin{figure}[H]
		\centering
		\caption{Preparação dos displays com o I2C e soldagem}
		\includegraphics[width=0.8\textwidth]{PrepI2CSoldagem}
		\label{fig:PrepI2CSoldagem}
	\end{figure}

	\item A próxima etapa foi soldar as trilhas por baixo conforme o diagrama PCB (Figura \ref{fig:diagramaModuloBase}). Também foi necessário soldar o I2C com o display. Essa é a etapa mais demorada, que poderia ser facilmente operacionalizada ao serem adotadas placas de circuito impresso, o que aumentaria muito a capacidade de montagem.

	\begin{figure}[H]
		\centering
		\caption{Preparação das caixas para os módulos}
		\includegraphics[width=0.8\textwidth]{PrepCaixasModulos}
		\label{fig:PrepCaixasModulos}
	\end{figure}

	\item Prossegue-se para a marcação das caixas para uso das furadeiras e lixas. Com ferramentas mais adequadas, essa etapa também poderia ser mais rápida e eficiente.

	\begin{figure}[H]
		\centering
		\caption{Caixa protetora, ligação dos botões e cabos de força}
		\includegraphics[width=0.8\textwidth]{BotoesCabosForca}
		\label{fig:BotoesCabosForca}
	\end{figure}

	\item Com a caixa preparada, foi possível inserir as placas padrão com os componentes e trilhas. Restou fixá-los com parafusos, montar a sustentação do display e sensor de presença (também integrado nesse passo), isopor para isolar termicamente o medidor de temperatura e umidade DHT, além de fazer as ligações dos botões, cabos de força e fios dos relés.

	\begin{figure}[H]
		\centering
		\caption{Quatro módulos prontos}
		\includegraphics[width=0.8\textwidth]{QuatroModulos}
		\label{fig:QuatroModulos}
	\end{figure}

\end{enumerate}

\subsubsection {Procedimento de Validação do Módulo}
\begin{enumerate}
	\item Carregar programa para testar módulo;
	\item Realizar setup da conexão com a rede Wi-Fi;
	\item Verificar com o multímetro se há curto em algumas ligações principais (terra, VCC);
	\item Checar a alimentação da fonte e sua saída correta;
	\item Realizar o \emph{hard reset} ao apertar o botão atrás do isopor do DHT até ouvir 10 bipes;
	\item Fazer o passo 2 novamente, pois o módulo deve ter voltado à versão de fábrica. Logo em seguida, fazer o teste de \emph{auto reset}, que serve para verificar se o circuito antitravamento está funcionando. Para esse teste, é simulado uma pausa do sinal \emph{keep alive} que o circuito baseado no astável 555 monitora;
	\item Cobrir o sensor de presença. Verificar a inatividade no aplicativo. Descobrí-lo e verificar atividade;
	\item Executar o passo 7 para o sensor de luminosidade (LDR) também;
	\item Verificar com um medidor externo ou consulta a um site de previsões do tempo se as medidas de temperatura e umidade estão de acordo. Realizar ajuste (offset) no aplicativo se necessário;
	\item Verificar o funcionamento dos botões, acionando-os um por um;
	\item Checar o acionamento dos relés pelo aplicativo web também;
	\item Após gravar o RF de um controle para os dois relés, testar seu funcionamento;
	\item Verificar com um multímetro a saída dos relés (se troca de nível com acionamento pela página web, botões e controle RF).
\end{enumerate}
\section{Evolução Arquitetural}
O processo de definição da arquitetura foi iterativo, seguindo um método de estabelecimento do modelo, validação e adequação. Para cada modelo foram analisadas as suas vantagens no cumprimento dos requisitos, bem como os seus pontos fracos, até a definição da arquitetura a ser implementada.

A primeira versão proposta baseava-se unicamente em microsserviços, responsáveis por toda a inteligência do projeto, o que a fazia interessante do ponto de vista da escalabilidade para um número muito grande de casas. Com uma arquitetura fundamentada dessa maneira, é possível a utilização transparente de quantas tecnologias forem necessárias ou desejáveis para cada um dos serviços, sem efeitos colaterais ou impactos em outros serviços. Por outro lado, cria-se uma grande complexidade na integração entre os serviços disponíveis. A complexidade pode ser gerenciada por técnicas já consolidades, como a coreografia e a orquestração \cite{lewis}.

Com o crescimento no número de microsserviços, o \emph{overhead} para a comunicação é aumentado, visto que cada requisição necessita solicitar um amplo número de serviços para que possa completar a sua tarefa. Há também um uso mais intenso da infraestrutura de comunicação, já que os serviços operam por troca de mensagens, as quais sofrerão aumento proporcional ao número de chamadas. As requisições aos microsserviços devem ser autenticadas e autorizadas, conforme o requisito RNF-11, de modo que foi proposto um \emph{gateway} para os serviços da nuvem, por onde passariam todas as requisições válidas no fluxo de comunicação com a casa. A inserção do \emph{gateway} cria um ponto único de falha, que pode ser evitado com técnicas de redundância e duplicação \cite{oracleSPOF}.

\begin{figure}[H]
	\centering
	\caption{Primeira versão da arquitetura do projeto Hedwig}
  \includegraphics[width=0.9\textwidth]{arquiteturaV1}
\label{fig:arquiteturaV1}
\end{figure}

É possível observar que alguns microsserviços são classificados como sensitivos, os quais dependem de nova consulta ao serviço de autenticação e autorização para garantir a segurança. Esses serviços são todos aqueles responsáveis por tomar uma ação em relação à casa que envolva riscos, como a abertura de portões. Os microsserviços não-sensitivos utilizam a autenticação já realizada pelo \textit{gateway} na chegada da requisição.

Quando uma requisição chega à nuvem, ela deve ser validada, para garantir a sua origem (RNF-11), e o método adotado faz uso de \emph{tokens}.  Caso passe nos critérios de autenticação e autorização, é retornado um JWT (\textit{JSON Web Token}), necessário para os passos seguintes. O JWT é discutido na seção \ref{sec:JWT}.

De extrema importância, e não cobertos pela arquitetura anterior, são os requisitos de disponibilidade do projeto (RNF-4). Se o \textit{gateway} estiver inacessível em determinado momento, a casa não terá mais nenhuma forma de comunicação com os meios externos, mesmo para os serviços mais básicos. Para resolver este problema, foi proposta uma segunda versão, conforme ilustra a imagem seguinte.

\begin{figure}[H]
	\centering
	\caption{Segunda versão da arquitetura do projeto Hedwig}
  \includegraphics[width=0.9\textwidth]{arquiteturaV2}
\label{fig:arquiteturaV2}
\end{figure}

Nesta versão, serviços essenciais seriam duplicados dentro da casa e, no caso de haver qualquer forma de impedimento na comunicação com a nuvem, esses serviços seriam responsáveis por controlar diretamente os atuadores desejados. Entretanto, cria-se mais uma complexidade ao manter serviços duplicados na casa, e no caso destes serviços também não estarem online no momento necessário, novamente não seriam alcançados requisitos de disponibilidade. Contudo, é uma versão que chega mais próxima de obedecer às necessidades do projeto.

Essa arquitetura provê módulos sem inteligência, e todo o controle é feito pelo serviço correspondente. Essa escolha desfruta de benefícios como a escalabilidade, a manutenção (já que é extremamente mais simples atualizar o software nos servidores do que nas residências) e a facilidade para prover correções ou possíveis aumentos de funcionalidade. Entretanto, alguns módulos poderiam ficar em lugares de difícil acesso --- ou mesmo fora da casa --- onde a comunicação poderia ser intermitente ou mesmo perdida. Assim, em caso de falha de comunicação, um atuador não receberia os sinais necessários do serviço, acarretando em sérios problemas na proteção da casa. No caso de uma garagem, por exemplo, o portão permaneceria aberto indeterminadamente, ou poderia não ser aberto quando o morador chegasse em sua casa.

Assim, avançou-se para o desenvolvimento de um modelo arquitetural modularizado, onde cada módulo teria inteligência para realizar as tarefas necessárias e, ao mesmo tempo, poderia enviar dados à nuvem e ser avisado quando for necessário realizar uma tarefa. Além disso, no aspecto comercial, módulos inteiros poderiam ser vendidos, substituídos e aumentados.

A arquitetura projetada faz uso de microsserviços no lado da nuvem e, no lado da casa, os componentes de hardware passam a ser agrupados em módulos independentes, com responsabilidades bem estabelecidas (RNF-1), inteligência e autonomia para realizar todas as atividades necessárias. Os módulos se comunicarão com um servidor local, que realizará, por último, a conexão direta com os serviços não locais. Esse servidor se comunicaria com os módulos por meio de mensagens enviadas em tópicos, as quais seriam interpretadas e enviadas aos servidores remotos em canais protegidos (RNF-2). O requisito RNF-8, relativo à escalabilidade, não será verificado no projeto, e pode ser considerado em passos futuros.

Em uma eventualidade, a comunicação entre o servidor local e a nuvem pode ser perdida.  O usuário, no entanto, deve conseguir se comunicar com a casa, ainda que tenha ao seu dispor uma quantidade mais restrita e essencial de ações --- como a liberação de acesso à casa. Quando é perdida a conexão entre a casa e os serviços externos, o servidor local armazena as mensagens vindas dos módulos, que serão transmitidas ao servidor remoto posteriormente. Como não há urgência para o processamento de tais dados (visto que não são requisições de ações, mas comunicação de estado) --- os quais serão utilizados para análise de comportamento e aprendizado de máquina (RF-5) --- não há prejuízo com o eventual envio tardio. O usuário poderá acompanhar o estado da casa, com as informações vindas dos sensores, por meio de um segundo aplicativo, denominado aplicativo backup.

No caso mais extremo, de perda de comunicação tanto com a nuvem quanto com o servidor local, como na ocorrência de falha de hardware do servidor local, os dados que os módulos tentam enviar ao servidor local serão perdidos, entretanto o aplicativo backup continua podendo se comunicar diretamente com os módulos, para ter acesso aos serviços de extrema importância.
\section{Módulos}
Para a criação dos módulos de hardware, foram escolhidos componentes de \wiot{} comerciais, que possuem preços acessíveis, ampla documentação disponível e uma comunidade de desenvolvedores crescente.

A interconexão dos componentes, bem como a comunicação com o mundo externo pela Internet é intermediada por um servidor local, instalado e disponível na plataforma Raspberry Pi, rodando um sistema operacional Linux (Raspbian, baseado em Debian) e que dispõe da interface de hardware necessária para conexão com a rede.

Os sensores e atuadores devem ser conectados fisicamente com um módulo controlador, e para que essa limitação fosse contornada, foram utilizados dispositivos ESP8266 --- Subseção \ref{subsec:esp8266} --- para transmissão sem fio por meio de Wi-Fi. Esses módulos são responsáveis pela transmissão das informações recebidas para o servidor local. Toda a arquitetura para essa transmissão será detalhada mais à frente. Os outros dispositivos a serem utilizados, como sensores DHT11, LM555, etc. podem ser vistos em uma lista completa no Apêndice \ref{listamateriais}.

Em geral, os módulos consistem do microcontrolador, relés, sensores e fontes\slash{}conversores de tensão a depender do módulo, além de um circuito para manutenção corretiva baseado no astável 555, conectados à rede Wi-Fi ou trabalhando como pontos de acesso. Para casos de falha de conexão, há um algoritmo de novas tentativas com tempos progressivamente maiores conforme as falhas ocorrerem, que busca deixar o módulo disponível para outras funções enquanto a conexão não está disponível. Para mitigar o travamento, um sinal de \textit{keep alive} é monitorado, e um circuito antitravamento deve ativar o \textit{hard reset} (\emph{reset} por hardware), ou então uma rotina de \textit{soft reset}, de modo que os requisitos RNF-5 e RF-9 sejam cumpridos. No entanto, observa-se que a segunda alternativa é a mais natural de se implementar, mas menos robusta, já que ainda pode não funcionar em casos de loop infinito.

\subsection{Módulos Base}
\subsubsection{ESP8266 \label{subsec:esp8266}}
O ESP8266 é um microprocessador com baixo consumo e radiotransmisor com conexão Wi-Fi 802.11 integrada \cite{espressif}. Pode ser programado usando a Arduino IDE, vastamente utilizada \cite{thomsen}. Opera com uma tensão de 3.3 V, suporta WPA e possui modo de interrupção somente por software. É amplamente usado como \textit{shield} para conexão Wi-Fi de placas de desenvolvimento da plataforma Arduino. Contudo, no projeto Hedwig, o dispositivo é utilizado em modo \textit{StandAlone} como principal processador e responsável pela conexão dos diferentes módulos de automação. Suas duas principais plataformas de desenvolvimento são Wemos\footnote{https://www.wemos.cc/} e NodeMCU\footnote{http://nodemcu.com/}. O projeto utiliza o Wemos D1 Mini, versão compacta do Wemos D1 R2.

O ESP8266 possui um modo de operação de baixa potência (\textit{sleep mode}) em que o consumo de bateria fica muito menor --- em contrapartida, o número de funcionalidades é limitado. Pode-se utilizar 7 portas de E\slash{}S digitais e uma porta de entrada analógica. Duas portas não são acessíveis, pois são utilizadas para programação e outras tarefas do sistema integrado do ESP8266. Alternativas para extensão de portas são:

\begin{enumerate}
	\item Utilização três níveis de sinal análogico para detectar três tipos de acionamento, através de um circuito dedicado, com priorização de entrada;

	\item Utilização interface I2C, como o usado para o display;

	\item Utilização de radiofrequência, por meio de um par receptor-transmissor integrado no módulo, controles, atuadores e sensores sem fio.
\end{enumerate}

\subsection{Módulo de Acesso}
\label{ssec:acessomodulo}

Buscando garantir mais segurança e comodidade para o acesso à residência, além do controle de abertura, o módulo de acesso atua em paralelo com uma fechadura eletrônica acionada por meio de controle remoto, que utiliza ondas de rádio para envio de dados. Assim, mesmo com falha total do sistema, o usuário poderá abrir o portão diretamente, sem a necessidade de acesso à Internet.

\begin{figure}[H]
	\centering
	\caption{Diagrama ilustrativo do Módulo de Acesso ao Portão}
  \includegraphics[width=0.8\textwidth]{diagramaModuloAcesso}
\label{fig:diagramaModuloAcesso}
\end{figure}

A Figura \ref{fig:diagramaModuloAcesso} ilustra em vermelho dispositivos já existentes no mercado, como o controle remoto. O sensor e a sirene sem fio adicionais são mostrados em verde --- são dispositivos externos ao módulo, que se comunicam por ondas de rádio. O próprio módulo de acesso, com um \emph{buzzer} embutido, e sua conexão com a rede local Wi-Fi ou sua conexão direta com o celular (quando o módulo opera como um ponto de acesso de rede) estão em amarelo. As funcionalidades adicionais são marcadas em roxo.

A comodidade, no exemplo em questão, está em abrir o portão por meio do celular, ao utilizar o aplicativo web ou o aplicativo local de emergência, sem a necessidade de carregar uma chave ou controle.

Entretanto, é necessário que a realização do controle de acesso seja feita de maneira segura. Assim, é empregado um algoritmo de rotação de teclas, para evitar que pessoas mal-intencionadas possam:

\begin{enumerate}
	\item Olhar e copiar a senha que o usuário digita em seu celular;
	\item \label{alt:manInTheMiddle} Copiar os dados de abertura e usá-los mais tarde (\textit{middle man}).
\end{enumerate}

Na alternativa alternativa \ref{alt:manInTheMiddle}, a cada acesso, um novo mapeamento de teclas é gerado e enviado ao usuário. Mesmo que haja cópia das credenciais, ela não funcionará devido ao mapeamento ter mudado. Observe ainda que a fechadura eletrônica, por si só, já estava vulnerável a este tipo de ataque --- há, inclusive, dispositivos copiadores de senhas comercializados.

Outro aspecto de segurança é a preocupação dos usuários em esquecer a porta ou portão abertos. Para mitigar esse perigo, o módulo deve monitorar por meio de um sensor o estado vigente (aberto ou fechado) conforme o requisito RF-1, e alertar localmente (por meio de \textit{buzzer}) e remotamente (e.g. por email ou notificação no smartphone) o usuário conforme o requisito RF-2. Essa e outras configurações como a de rede são acessadas por uma senha diferente daquela de abertura, de modo que a interface básica seja simples para uso.

Para o caso de falha de envio de notificação (e.g. servidor fora do ar ou indisponibilidade na conexão), há um algoritmo de novas tentativas com tempos progressivamente maiores conforme as falhas ocorrerem, buscando deixar o módulo disponível para outras funções. Tratamento análogo é realizado no servidor local, e no sistema de mensageria, de modo a evitar perdas de mensagens mesmo em situações desfavoráveis. Para o caso de falta de conexão à Internet, o módulo não seria controlável pela nuvem com o aplicativo web, mas sim com o aplicativo emergencial usando a ativação do \textit{Access Point}, desenvolvido para operar diretamente com os módulos, sem intermédio do servidor local e dos serviços remotos.

Por meio das credenciais disponíveis no sistema, é possível saber qual dos usuários solicitou a abertura do portão. A persistência destes acessos pode ser analisada e, utilizando-se técnicas de aprendizado de máquina, perfis de acesso podem ser determinados, e evoluir até que o sistema saiba quando houver um acesso em horário inesperado e possa notificar o usuário remotamente, conforme o requisito RF-5. O aprendizado de máquina é fundamental aqui para descobrir comportamentos que podem ser entendidos como suspeitos. Um exemplo prático de caso de uso seria um usuário que costuma chegar em um horário semelhante todos os dias e realizar certo conjunto de tarefas na casa. Uma tentativa de acesso que não se enquadre em tais padrões pode ser produto de atividade suspeita, a qual pode ser informada pela casa para uma central, que acionaria a polícia caso seja confirmado que não se trata de um falso positivo.

\subsection{Módulo de Quarto/Sala/Cozinha}
Um dos módulos com muitas opções de implementação e uso é o módulo de quarto, pois ele também pode ser usado no controle de iluminação para corredores, salas e ambientes externos.

\begin{figure}[H]
	\centering
	\caption{Diagrama ilustrativo do Módulo de Quarto/Sala/Cozinha}
	\includegraphics[width=0.8\textwidth]{diagramaModuloQuarto}
	\label{fig:diagramaModuloQuarto}
\end{figure}

O diagrama ilustra equipamentos externos ao sistema (lâmpada e abajur) em vermelho, enquanto o controle e sensor de abertura possuem comunicação sem fio. Em roxo, representam-se os equipamentos opcionais.

Como principais funcionalidades, tem-se o despertador (configurado pelo usuário, que também pode receber recomendações baseadas na informação gerada pelo monitoramento de seus ciclos de sono); monitoramento de temperatura e umidade do ambiente (que podem ser notificadas ao usuário, caso informem valores fora de determinados intervalos); controle de iluminação (da luz direta, que é a lâmpada central do ambiente, com maior potência, e da luz indireta, que é usualmente um abajur ou uma lâmpada com menor potência, usada para leitura); e estado da janela, para verificar remotamente se a janela está fechada ou não (por notificação ou visualização no aplicativo, útil para dias chuvosos). Além disso, se o módulo for instalado em ambientes internos e externos, o usuário pode usufruir de dados de temperatura e umidade, que podem ser usados para escolher a vestimenta, optar por levar guarda-chuva na ida para o trabalho ou decidir se é mais vantajoso deixar roupas secando dentro ou fora de casa, e em que períodos.

O módulo de quarto pode ser acoplado ao sistema existente --- fisicamente, é instalado no mesmo lugar do interruptor ---, e possui estados para o despertador. No estado inicial, somente a luz indireta é ligada. Após determinado tempo programável pelo usuário, há avisos sonoros periódicos. No terceiro estado, os períodos são menores. Finalmente, no quarto estado a luz direta é ligada e os avisos sonoros são ininterruptos. Até o terceiro estado, o alarme pode ser desarmado (apertar duas vezes) ou entrar em estado soneca (apertar única vez) diretamente no módulo. Já no estado 4, a critério anterior do usuário, o alarme pode ser desarmado somente fisicamente em outro módulo presente em um segundo aposento --- por exemplo, na sala. Esse módulo pode variar de dia para dia, caso o usuário assim desejar. O sistema desarma o alarme após 40 minutos.

O display possui iluminação automática por meio de circuito baseado em LDR para não apresentar brilho muito intenso quando todas as luzes estiverem desligadas. Para o controle da iluminação, há diferentes tempos de desligamento. Por exemplo, quando ocorre controle manual pelo botão presente no módulo, o tempo pode ser maior (e.g. 30 minutos). Já pelo modo automático, quando a luz já foi ligada pelo próprio módulo, o tempo para desligamento pode ser menor (e.g. 4 minutos).

Com o monitoramento da presença, há um reinício da contagem para desligamento sempre que houver presença detectada, de forma a inibir acionamentos desnecessários do relé. Outra aplicação para o monitoramento da presença é a descoberta de comportamento anormal. Por exemplo, se o usuário sempre toma café entre 8 e 10 horas, e não apresentar presença na casa até às 15 horas, o sistema pode notificar emails de parentes cadastrados.

\subsection{Módulo de Aquário}

Devido a altos custos de compra, implantação e manutenção de um aquário, que pode ser de água doce ou salgada, e até abrigar espécies raras, é desejável que uma série de riscos sejam mitigados. Dentre tais riscos, destacam-se:

\begin{table}[hbp]
		\centering
		\caption{Riscos para o aquário}
		\resizebox{\textwidth}{!}{%
		\begin{tabular}{cp{8cm}p{8cm}}
			\toprule
			\textbf{Perigo/Necessidade} 					& \textbf{Origem} 																			& \textbf{Consequência}  \\
			\midrule
			Aquecimento acidental 							& Ajuste errado da temperatura do termostato												& Superaquecimento; risco de mortes (peixes e plantas) \\
			Falta de água 									& Vazamento ou evaporação natural															& Mal funcionamento ou queima da bomba submersa (à longo prazo, falta de oxigenação da água) \\
			Falta de circulação de água 					& Entupimento do tubo de circulação ou mal funcionamento da bomba							& Falta de oxigenação da água, ocasionando em risco de mortes (peixes) \\
			Iluminação adequada								& Existência de plantas e/ou iluminação natural insuficiente no ambiente do aquário			& Ambiente nocivo para os peixes, risco de morte das plantas (principalmente durante períodos de esquecimento/viagens) \\
			\bottomrule
	\end{tabular}}
	\label{table:riscosaquario}
\end{table}

Sobre o caso específico da residência onde foram executados os testes de campo, considere um aquário com 50 litros de água, com uma bomba para circulação de água e um aquecedor, com cerca de 50 peixes de pequeno porte, que são sensíveis à variação brusca de temperatura.

Na ocasião de troca de água do aquário, cerca de 20\% do volume total é substituído. A saída de água se dá por um funil, e a adição é realizada pela bomba, que introduz água limpa, sem cloro e com menos amônia e outros compostos nocivos aos peixes (que justificam essa troca periódica de água). O monitoramento do nível da água pode também mitigar o risco de esquecimento.

\begin{figure}[H]
	\centering
	\caption{Diagrama ilustrativo do Módulo de Aquário}
	\includegraphics[width=0.8\textwidth]{diagramaAquario}
	\label{fig:diagramaAquario}
\end{figure}

Para mitigar os riscos descritos anteriormente, foi desenvolvido o módulo de aquário, que permite:

\begin{enumerate}
	\item Controle de horários em que a lâmpada fica acesa, fornecendo uma iluminação adequada para as plantas e peixes do aquário em períodos curtos de viagem;
	\item Monitoramento do nível de água do aquário principal, com disparo de alerta pelo aplicativo quando não estiver no nível esperado --- o que pode ocorrer por muita evaporação, vazamento ou problema com a bomba;
	\item Monitoramento da temperatura do aquário, e bloqueamento do aquecedor caso a água já esteja numa temperatura desejável, evitando superaquecimento devido a mal funcionamento do termostato --- isso é feito por meio de ligação em série com o termostato do aquário;
	\item Nos casos de perigo acima descritos, também disparar alerta sonoro localmente por meio do \emph{buzzer}.

\end{enumerate}

\subsection{Módulo de Interface com Sistema de Alarmes}

O módulo de interface com o sistema de alarmes monitora dois aspectos específicos: um relativo à presença, possuindo sensores no corredor e na sala da residência, e outro relativo à porta da sala, com um sensor único na porta da residência. O módulo implementado foi instalado em uma residência em Jarinu - SP.

\begin{figure}[H]
	\centering
	\caption{Diagrama ilustrativo do Módulo de Interface com Sistema de Alarmes}
	\includegraphics[width=0.8\textwidth]{diagramaAlarme}
	\label{fig:diagramaAlarme}
\end{figure}

Um problema recorrente é a conexão com a Internet, que, apesar da indicação de estado válido e conectado, não fornecia acesso a sites, tampouco acesso externo por meio de abertura de porta no roteador. Para contornar esse problema e permitir que o módulo esteja disponível para coleta de dados e persistência em cartão SD, foi instalado também um relé NF (normalmente fechado) em série com a alimentação do roteador (no caso do módulo estar desligado, o roteador ficará ligado).

Já quando há erro persistente (maior que 10 vezes em intervalos de 2 a 3 minutos) ao realizar a operação de \emph{ping} com sites ou servidores conhecidos, o módulo reinicia a conexão atuando diretamente no roteador. Ocorre a execução deste procedimento em intervalos cada vez mais espaçados, de forma a não executar muitas vezes o reinício do roteador sem que a conexão seja reestabelecida com sucesso. Nas primeiras tentativas, tem-se um intervalo de 3 minutos até a nova tentativa, a partir da terceira vez um intervalo de 10 minutos, e assim por diante, até um máximo de 30 minutos.

Outra dificuldade encontrada em sua instalação em campo foi a obtenção de endereço IP dinâmico em uma rede em que outros dispositivos, tais como celulares e tablets, também obtinham endereços IP dinâmicos, gerando indisponibilidades do módulo. Com a mudança do endereço IP para fixo, em outro intervalo de endereçamento, o módulo passou a ter alta disponibilidade, ficando até semanas sem reiniciar.
\section{Servidor na Nuvem}

O servidor na nuvem tem a responsabilidade de realizar a comunicação entre as aplicações cliente disponíveis para o usuário final e as casas inteligentes, de armazenar os dados coletados pelos sensores e de realizar processamentos que sejam muito onerosos para a capacidade dos dispositivos físicos locais. A seguir, são explorados os conceitos que orientaram o design da arquitetura e a implementação do servidor do Hedwig.

\subsection{Computação em Nuvem}

O projeto Hedwig opta por uma solução voltada à nuvem. Os componentes do servidor são hospedados na nuvem pelas seguintes vantagens \cite{viswanathan}:

\begin{description}
\item[Custo -]O investimento em servidores próprios geralmente possui um alto custo. Em contrapartida, os fornecedores de \emph{Infrastructure as a Service --- IaaS}, oferecem várias modalidades de precificação que vão desde assinaturas periódicas até pacotes que impõem limites de requisições.
\item[Escalabilidade -]Existe uma grande facilidade em escalar os recursos de forma rápida. Os serviços de nuvem permitem manipular características como capacidade de disco, tamanho de memória e tipo de processador das instâncias que rodam os programas e aplicações. Também é possível seguir o caminho da escalabilidade horizontal e simplesmente replicar instâncias ao invés de melhorar suas especificações técnicas.
\item[Alocação de recursos eficiente -]Com a precificação flexível e a facilidade em escalar, é possível aproveitar melhor a capacidade de processamento disponível e evitar desperdício com recursos ociosos.
\item[Backup e recuperação de dados -]Os serviços de nuvem já providenciam funcionalidades de backup e restauração de dados, que podem ser tarefas arduosas para realizar em dispositivos físicos.
\end{description}

\subsection{Banco de Dados Não-relacional}

Bancos de dados não-relacionais são modelados de forma alternativa às tabelas relacionais dos sistemas SQL. São muitas vezes chamados de bancos NoSQL, que adquiriu o significado de \emph{Not Only SQL} \cite{nosql}. Algumas das características predominantes são a facilidade de escalabilidade horizontal, por meio de replicação e ``clusterização'', e a priorização da disponibilidade ao invés da consistência. Esse último ponto pode ser sintetizado no conceito de BASE --- \emph{Basically Available, Soft state, Eventual consistency} ---, que é colocado em contraposição às garantias popularmente oferecidas pelos bancos relacionais: Atomicidade, Consistência, Isolamento, Durabilidade (\emph{Atomicity, Consistency, Isolation, Durability} - ACID). Apesar disso, alguns dos bancos NoSQL possuem características compatíveis com ACID. Esse tipo de banco de dados é bastante utilizado em aplicações web de tempo real e de \emph{Big Data} \cite{pereira}.

Os bancos de dados NoSQL podem usar vários esquemas para modelar os dados que armazenam: colunas, documentos, pares chave-valor, grafos ou uma mistura dos anteriores. Dentre eles, destacam-se os documentos, também chamados de dados semi-estruturados. Documentos são dados codificados em XML, JSON, YAML ou em outros formatos ou códigos, incluindo até mesmo binários. Geralmente, não seguem nenhum esquema rígido, o que torna o desenvolvimento mais flexível e facilita a incrementação dos modelos com novos dados.

\subsection{Banco de Dados em Memória}

Bancos de dados em memória usam a memória principal do computador para realizar o armazenamento de dados ao invés de dispositivos de armazenamento em disco \cite{raima}. Como o tempo de acesso em disco é muito maior, esse tipo de banco de dados é capaz de atingir altos níveis de performance, proporcionando latências menores e mais previsíveis.

É um método de armazenamento mais caro \cite{mullins}, visto que a unidade de espaço em RAM é mais cara a de que disco. Assim, muitos projetos optam por uma arquitetura híbrida que usa tanto esse tipo de banco de dados quanto os tradicionais de acesso em disco. Devido ao fato da memória RAM ser volátil, esse tipo de abordagem também é usado para evitar perdas de dados em casos de falhas.

\subsection{WebSockets \label{sub:websocket}}

WebSocket é um protocolo de comunicação \emph{full-duplex} sobre conexões TCP \cite{rfc6455}. Ele possibilita a comunicação interativa entre cliente e servidor sem a necessidade de disparar múltiplas requisições HTTP, permitindo também que o servidor envie conteúdo ao cliente sem que este tenha que requisitá-lo.

É um protocolo da camada de aplicação compatível com HTTP: a transição entre esses dois protocolos é feita por meio de um \textit{handshake} que usa o cabeçalho de \texttt{HTTP Upgrade}, como observado na Figura \ref{fig:websocketVsPolling}.

A sua arquitetura diminui as latências de comunicação em relação às técnicas de \emph{polling}, que envolvem simplesmente a realização periódica de requisições HTTP, fazendo-o ser um protocolo popular entre aplicações de tempo real. A compatibilidade com HTTP permite que toda a troca de dados ocorra nas portas 80 ou 443, mitigando os problemas de incompatibilidade com ambientes que possuem \emph{firewalls} bloqueando certas portas TCP. A maioria dos navegadores modernos implementa o protocolo de WebSockets, possibilitando o funcionamento de aplicações de chat e de notificações.

\begin{figure}[H]
	\centering
	\caption{Comparação entre WebSockets e \emph{polling}}
  \includegraphics[width=0.7\textwidth]{websocketVsPolling}
	\caption*{Fonte: \cite{lubbers}}
\label{fig:websocketVsPolling}
\end{figure}

\subsection{Arquitetura de Microsserviços}

A arquitetura de microsserviços é um modelo que compreende a estruturação de uma aplicação em um conjunto de serviços com baixo grau de acoplamento que se comunicam por meio de protocolos de comunicação leves.

Para melhor compreender essa arquitetura, pode-se compará-la à arquitetura monolítica. Uma aplicação monolítica está contida em uma única unidade, que geralmente é dividida em camadas de funcionalidade tecnológica como interface web, camada de negócios \emph{server-side} e camada de persistência de dados. A escalabilidade desse modelo é dada por meio do aumento do número de servidores, máquinas virtuais ou contêineres juntamente a um balanceador de carga --- é a chamada escalabilidade horizontal. Uma alteração em uma pequena parte da aplicação significa que toda a aplicação deverá passar por um processo de \textit{build} e \textit{deploy}. Já a arquitetura de microsserviços divide as funcionalidades em serviços autônomos, muitas vezes usando as regras de negócios para realizar essa divisão. Cada serviço tem seu próprio ciclo de desenvolvimento e pode ser atualizado independentemente. A escalabilidade também é tratada serviço a serviço.

\begin{figure}[H]
	\centering
	\caption{Comparação entre uma aplicação monolítica (esquerda) e com microsserviços (direita)}
  \includegraphics[width=0.8\textwidth]{estruturaMicrosservicos}
	\caption*{Fonte: \cite{lewis}}
\label{fig:estruturaMicrosservicos}
\end{figure}

É difícil delimitar uma definição formal para arquitetura de microsserviços, pois não existe consenso a respeito dela. Contudo, existe uma série de características que projetos usando essa arquitetura compartilham. Detalham-se a seguir alguns atributos e aspectos dos microsserviços. Nem todos os projetos possuem rigorosamente todas as características, mas a maioria deles possui um perfil similar ao descrito aqui.

\begin{description}
\item[Serviços são processos -]Pode-se fazer um mapeamento de um processo para um serviço, porém isso é apenas uma aproximação, podendo um serviço ser constituído por uma aplicação de múltiplos processos;
\item[Serviços comunicam-se por protocolos leves -]Geralmente, são usados protocolos como o HTTP;
\item[Serviços implementam capabilidades do negócio -]Isto é, a divisão de serviços é baseada nas regras de negócio e nas funcionalidades que o produto deverá suprir;
\item[Serviços são facilmente substituíveis - ]Por serem pequenos e independentes;
\item[Cada serviço tem um ciclo de vida independente -]Isso inclui o desenvolvimento e os processos de \emph{deploy}. Um microsserviço pode ser implementado e atualizado independentemente dos outros.
\end{description}

As vantagens da arquitetura de microsserviços giram em torno da modularidade e autonomia dos serviços que é natural à sua estrutura. Com isso, pode-se ter uma heterogeneidade de tecnologias, isto é, cada serviço pode ser desenvolvido usando diferentes linguagens, \textit{frameworks} e ferramentas de acordo com seus requisitos. A independência entre serviços também possibilita a implantação automatizada e o uso de práticas de integração contínua. Também há benefícios de aspecto gerencial: como cada serviço tem como escopo uma capabilidade do negócio que envolve interfaces de interação com usuário, código em várias camadas que implementa as funcionalidades necessárias e persistência em bancos de dados, é possível criar pequenas equipes multidisciplinares para cada microsserviço.

Existem \emph{trade-offs} que devem ser considerados ao decidir pela arquitetura de microsserviços. A comunicação entre serviços por meio de uma rede possui maior latência e exige maior processamento do que mensagens trocadas a nível de processos. Por isso, é muito importante analisar as fronteiras dos serviços e a alocação de responsabilidades durante do projeto. A descentralização de dados entre microsserviços traz também a necessidade de métodos para manter a consistência das informações. Outro ponto crítico são sistemas com alta granularidade de microsserviços, causando \emph{overhead} tanto de comunicação como de código, além de uma fragmentação lógica que causa mais impactos negativos na complexidade e performance do que benefícios --- tal caso de antipadrão foi chamado de nanosserviço \cite{rotem}.

Os microsserviços podem ser vistos como um estilo específico de arquitetura orientada a serviços (\textit{Service-oriented architecture} --- SOA), visto que existem várias características compartilhadas entre os dois. Contudo, o termo arquitetura orientada a serviços é mais amplo, e muitas de suas implementações podem não seguir certos pontos apresentados como aspectos dos microsserviços. Pode-se citar como por exemplo dessa situação o uso de grande inteligência no mecanismo de comunicação de dados ao invés de delegar tal complexidade aos \emph{endpoints} do serviço \cite{lewis}. Esse e outros problemas conhecidos das experiências passadas de sistemas estruturados em SOA fazem com que muitos encarem os microsserviços como uma modernização da arquitetura orientada a serviços.

Apesar do termo microsserviço ter surgido por volta de 2011 \cite{lewis}, as ideias por trás desse estilo arquitetural não são recentes. O aumento da discussão em torno dos microsserviços nos últimos anos pode ser creditada a avanços tecnológicos tais como a disseminação dos serviços de nuvem, o crescimento de ferramentas de automatização de implantação, a consolidação dos conceitos de \emph{DevOps}, entre outros.
\section{Cliente Web}
\label{archweb}
A arquitetura do Hedwig permite o desenvolvimento de múltiplos aplicativos clientes independentes para monitorar e controlar os dispositivos conectados de uma casa. Como toda a comunicação desses clientes é realizada através do servidor na nuvem por meio de WebSockets e da API REST, é possível realizar integrações em diversas plataformas, seja em navegadores ou em sistemas operacionais nativos de smartphones.

A fim de demonstrar como o usuário final poderia interagir com o sistema em sua totalidade, optou-se por desenvolver uma aplicação web. Esse tipo de aplicação foi escolhida devido à vasta quantidade de bibliotecas, \emph{frameworks}, ferramentas e IDEs disponíveis. Outro fator favorável é a evolução dos navegadores modernos, que possuem funcionalidades de depuração e integrações com os ambientes de dispositivos móveis cada vez melhores. Tais melhorias possibilitaram que aplicativos web pudessem ter uma aparência e percepção mais próxima aos de aplicativos nativos.

\subsection{\emph{Progressive Web Apps}}

\subsubsection{Contexto}
Durante a ascensão dos smartphones no mercado, os aplicativos nativos predominaram por serem mais rápidos e possuírem maior suporte para acessar funções do hardware, alcançando assim um padrão melhor de experiência de usuário do que aplicativos web. Em 2007, Steve Jobs chegou a afirmar que sua visão para o iPhone era de que todos os aplicativos de terceiros fossem \textit{web apps} \cite{9to5mac}. Contudo, apesar desse incentivo, o panorama de Jobs não foi recebido com muita empolgação, e a App Store foi ao ar em 2008 com 500 aplicativos \cite{ricker}. Em janeiro de 2009, já estavam disponíveis mais de 15 mil aplicativos, com um total de downloads que superava 500 milhões \cite{myslewski}.

Desde então, ocorreram grandes avanços no desenvolvimento web com o amadurecimento do HTML5, CSS3 e JavaScript, a criação de novas bibliotecas e ferramentas, surgimento de mais metodologias para design responsivo e a evolução dos navegadores para cumprir os padrões e especificações mais recentes.

Assim, houve o crescimento do número de aplicativos híbridos, que combinam as técnicas de desenvolvimento web com benefícios dos aplicativos nativos como o suporte para usar funções do hardware. Podem-se dividir os aplicativos híbridos em dois grandes grupos \cite{rudolph}: aplicativos que usam WebView, uma espécie de navegador interno que é envolvido por uma aplicação nativa, permitindo que algumas APIs nativas sejam acessíveis por JavaScript, e aplicativos híbridos compilados, que são escritos em uma linguagem não nativa e então compilados para várias plataformas de dispositivos móveis. Isso permite obter versões para diversas plataformas com o mesmo código, apesar de que para obter tal resultado, são impostas diversas limitações durante o desenvolvimento.

Hoje, pesquisas indicam que os aplicativos nativos vêm perdendo força. O número de downloads de aplicativos no Estados Unidos diminui 20\% ano a ano \cite{benson}. Analisando os dados da Google Play, descobriu-se que o aplicativo médio perde aproximadamente 77\% dos usuários após 3 dias da instalação \cite{chen} --- o que demonstra a dificuldade de se alcançar um bom nível de engajamento. Logo, pedir que o usuário baixe um aplicativo para continuar desfrutando dos serviços de um site pode acarretar em evasão de visitantes. Esses fatores somam-se ao fato de que as tecnologias de desenvolvimento web continuam progredindo e permitindo experiências de usuário cada vez mais ricas --- há um crescente suporte na forma de bibliotecas e metodologias para criar interfaces responsivas, transições e animações fluidas e novos tipos de interação. Nesse contexto, surge o conceito de \textit{Progressive Web Apps}, aplicações web que, de fato, podem oferecer uma experiência compatível à de uma aplicação nativa.

\subsubsection{Conceito}
O conceito de \textit{Progressive Web Apps} ou PWAs é recente --- o termo foi usado pela primeira vez em 2015 pelo designer Frances Berriman e pelo engenheiro do Google Chrome Alex Russell \cite{russell}. A ideia dessa classe de aplicativos é ir além das aplicações web tradicionais, aproveitando o máximo das funcionalidades mais modernas dos últimos navegadores lançados e combinando-as à navegação móvel para oferecer uma melhor experiência ao usuário.

De acordo com o Google Developers \cite{googledevpwa}, os PWAs devem ser:

\begin{description}
\item[Confiáveis -]devem carregar de forma instantânea, independentemente das condições de conectividade, sem prejudicar a experiência com erros e falhas na aplicação;
\item[Rápidos -]devem responder rapidamente às interações do usuário, com animações e renderizações suaves;
\item[Envolventes -]devem oferecer uma experiência imersiva, que se assemelhe à de um aplicativo nativo.
\end{description}

Além desses três principais aspectos, várias outras características para definir PWAs mais a fundo também são exploradas pelas documentações do Google Developers \cite{googledevpwachecklist} e por outros desenvolvedores web. Abaixo estão algumas delas:

\begin{description}
\item[Responsivos -]adaptação aos mais variados tipos de dispositivos e plataformas: desktops, smartphones, tablets, \textit{smart TVs}, entre outros;
\item[Atualizados -]podem realizar a atualização automática do conteúdo;
\item[Seguros -]uso de medidas para evitar a adulteração de conteúdo;
\item[Descobríveis -]podem ser encontrados por mecanismos de pesquisa e identificados como aplicativos;
\item[Linkáveis -]o seu conteúdo é compartilhável por URLs.
\end{description}

As ideias em torno do desenvolvimento dos PWAs são fortemente relacionadas ao conceito de \textit{progressive enhancement} ou melhoria progressiva, que propõe que camadas de interface e funcionalidades sejam progressivamente adicionadas à aplicação à medida que a conexão e navegador do usuário permitam \cite{champeon}. Dessa forma, usuários com dificuldades de conectividade e dispositivos mais antigos podem acessar o conteúdo básico, e aqueles que possuem mais banda e navegadores mais modernos podem acessar uma versão mais completa.

\subsubsection{Tecnologias e Técnicas}

\begin{description}

\item \textbf{Manifesto}

O manifesto é um arquivo de texto que oferece informações básicas sobre um aplicativo, como nome, autor, ícone, e descrição. Ele permite que os usuários adicionem o aplicativo à tela inicial de seus aparelhos para acessá-lo mais rapidamente.

\item \textbf{\textit{Service Workers}}

\textit{Service workers} são scripts executados em segundo plano pelo navegador que realizam tarefas que não necessitam de uma página web ou de interações imediatas com o usuário. Aplicações populares para \textit{service workers} são as notificações \textit{push} e a sincronização em segundo plano.

\end{description}

\subsubsection{Aplicações}
Com o uso de notificações \textit{push}, a eXtra Electronics, comércio de eletrônicos e eletrodomésticos da Arábia Saudita, obteve um grande aumento de conversão na sua loja virtual. Com uma taxa de cliques nas notificações de 12\%, os usuários que optaram por ativar essa funcionalidade retornavam 4 vezes mais ao site e o total das receitas de suas compras aumentou em 100\% \cite{googledevextra}.

Outro caso de sucesso na área de \textit{e-commerce} é o da AliExpress, que focou na performance e nas funcionalidades offline para obter um aumento de 104\% na conversão vinda de usuários novos \cite{googledevaliexpress}.

O Twitter PWA Lite conseguiu reduzir o uso de dados em até 70\% usando imagens otimizadas e se aproveitando ao máximo das informações no cache. Houve um aumento de 75\% da quantidade de \textit{tweets} enviados \cite{googledevtwitter}.

\subsection{JSON \textit{Web Tokens} \label{sec:JWT}}

\subsubsection{Definição}
O cliente web realiza a autenticação de usuário por meio de JSON \textit{Web Tokens}. JSON \textit{Web Tokens}, ou JWTs, foram definidas para possibilitar a troca de informações de forma segura, autônoma e compacta usando objetos JSON \cite{rfc7519}. A segurança se dá pela assinatura digital das tokens usando o algoritmo HMAC com um segredo ou com criptografia RSA usando pares de chaves pública e privada. JWTs são autônomas no sentido de que o conteúdo das \emph{tokens} contém toda a informação sobre o usuário, evitando transações adicionais no banco de dados. Por fim, o tamanho compacto das tokens permite que elas sejam enviadas em URLs, parâmetros e cabeçalhos HTTP sem grande ônus ao tempo de transmissão.

Uma token é uma string composta por três partes separadas por pontos. As três partes são: Cabeçalho, Corpo e Assinatura. O Cabeçalho típico contém o tipo da token --- ou seja, JWT --- e o algoritmo de \textit{hashing} usado, como por exemplo HMAC, SHA256 ou RSA. O Corpo é constítuido por \textit{claims} (afirmações) sobre a entidade, geralmente o usuário. As \textit{claims} podem ser de três tipos: reservadas, que geralmente são informações úteis predefinidas como o tempo de expiração, públicas e privadas. O Cabeçalho e o Corpo são codificados usando Base64Url e são usados para criar a Assinatura com o algoritmo definido previamente. A token final é, então, o resultado da concatenação do Cabeçalho e do Corpo codificados e da Assinatura.

\subsubsection{Autenticação}

Para realizar a autenticação com JWTs, as \emph{tokens} são geradas na nuvem durante o cadastro ou login do usuário e então são enviadas ao navegador. A partir desse momento, todas as requisições ao servidor da nuvem irão conter a JWT no campo \texttt{Authentication} do cabeçalho HTTP. Somente requisições contendo \emph{tokens} válidas são aceitas no \emph{back-end} da aplicação. Essa estratégia de implementação é amplamente utilizada para desenvolver a funcionalidade de \textit{single sign-on}.

Um exemplo de cabeçalho HTTP que usa JWT para autenticação é:

\begin{lstlisting}
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
\end{lstlisting}

No Hedwig, o servidor na nuvem, ao receber um pedido de autenticação e validá-lo, gera a JWT e a manda para o aplicativo cliente, que a armazena no \textit{local storage}. O \textit{local storage} é uma forma de armazenamento no navegador que permite que aplicações guardem dados que persistam além da duração de uma sessão. É considerada uma alternativa aos cookies com maior capacidade e segurança \cite{w3cWebStorage}.

Os navegadores em geral podem armazenar em torno de 300 cookies, com um limite de aproximadamente 20 por domínio, cada um com um tamanho máximo de 4kB \cite{cookies}. Já os limites para o local storage geralmente são de, no mínimo, 5MB por domínio \cite{localstorage}.

\begin{figure}[H]
	\centering
	\caption{Diagrama de interação na autenticação por JWT}
  \includegraphics[width=\textwidth]{jwtDiagram}
  \caption*{Fonte: \cite{jwt}}
\label{fig:jwtDiagram}
\end{figure}

A autenticação com JWT é \textit{stateless}, pois não há necessidade de guardar o estado de autenticação do usuário no banco de dados. Ao contrário dos cookies, as tokens podem ser compartilhadas por vários domínios sem as limitações de \textit{Cross-Origin Resource Sharing} (CORS). Isso possibilita que uma única token possa ser repassada serviço a serviço para completar uma transação que necessita de autenticação em um sistema mais complexo, como é o caso da arquitetura de microsserviços.
\section{Comunicação}

Conforme explicado anteriormente, neste projeto são utilizados tanto protocolos de comunicação próprios quanto os criados por terceiros. A arquitetura desenvolvida aqui busca viabilizar a robustez do sistema, trabalhando em ambos os níveis local e remoto, com o usuário tendo o controle de sua casa por meio de um smartphone ou computador pessoal.

O serviço em nuvem recebe as requisições do usuário por meio de um cliente web ou nativo. Esse servidor processa as requisições, aplicando os filtros de segurança necessários, de modo a consultar a autenticidade do pedido e verificar se aquele usuário possui as permissões necessárias para o serviço que deseja operar. Os serviços da nuvem se comunicam com o servidor local da casa requisitada, o qual também aplica os filtros de segurança necessários e então realiza a comunicação com os módulos.

A arquitetura de comunicação é representada pela Figura \ref{fig:diagramaComunicacao} com um alto nível de abstração. Detalhes sobre a implementação e as mensagens trocadas entre servidor local, módulos e nuvem serão vistos com menor granularidade na Seção \ref{chap:morpheus}.

\begin{figure}[H]
	\centering
	\caption{Visão alto nível da comunicação no Hedwig}
	\includegraphics[width=0.8\textwidth]{arquiteturaHedwig}
	\label{fig:diagramaComunicacao}
\end{figure}

\subsection{Comunicação entre Controlador Local e Módulos}

A infraestrutura de comunicação entre o servidor local e os módulos com sensores e atuadores utiliza o protocolo de aplicação \wmqtt{}, referência em aplicações \wiot{} no mundo. O protocolo \wmqtt{} é estabelecido em cima dos protocolos TCP/IP e é orientado à sessão, diferentemente do protocolo HTTP, localizado na mesma camada \cite{ibmMqtt}.

O protocolo \wmqtt{} é do tipo \emph{Pub/Sub} (de \textit{publisher/subscriber}) e é estritamente orientado a tópicos. Assim, um \textit{subscriber} se inscreve a um tópico de seu interesse, e recebe todas as publicações que um \textit{publisher} realizar. Os tópicos são organizados com estrutura semelhante a de um sistema de arquivos Unix, com níveis hierárquicos separados por barras, de modo que o subscriber pode se inscrever para tópicos utilizando os \textit{wildcards} * e +, os quais são válidos para mais de um nível e um único nível, respectivamente \cite{mqttDocumentation}.

Para interconectar os tópicos com \textit{publishers} e \textit{subscribers}, é necessário um agente que realiza a transmissão das mensagens e que garante a segurança e confiabilidade. Esse agente é conhecido como \emph{broker} (em versões anteriores) ou \emph{server} (na versão atual, V3.1.1). O \textit{broker} permite ou nega a subscrição ou a publicação a determinado tópico. A segurança da troca de mensagens é realizada por meio do protocolo TLS (\textit{Transport Layer Security}) que encripta os segmentos na camada de transporte.

O protocolo \wmqtt{} também oferece três tipos de QoS (\textit{Quality of Service}), possibilitando: diminuir o \emph{overhead} ao máximo, enviando a mensagem uma única vez, na configuração mais simples; garantir que a mensagem seja entregue no mínimo uma vez, na configuração de segundo nível; garantir que a mensagem seja entregue exatamente uma vez, no terceiro nível, o que consequentemente aumenta o \emph{overhead}.

As mensagens são transmitidas em texto puro, e é necessário estabelecer um protocolo para a sua utilização. Foi desenvolvido um protocolo de fácil utilização e com baixo \emph{overhead}, mas que pudesse ser expansível e flexível aos casos de uso desejados.

O \textit{broker} Mosquitto\footnote{https://mosquitto.org/} é utilizado no Hedwig. Ele foi escolhido por ser amplamente adotado em projetos de \wiot{}, além de ser \emph{open-source} e ter licença abrangente (MIT). Entretanto, há outras diversas possibilidades, como o HiveMQ, adotado no projeto HomeSky e com grande uso em aplicações enterprise \cite{hiveMq}.

\subsection{Comunicação entre Controlador Local e Nuvem}

Inicialmente, foi proposto um modelo arquitetural para a comunicação com a nuvem no qual existiriam \emph{endpoints} para requisições HTTP tanto do lado da casa quanto do lado da nuvem. Assim, quando o Morpheus precisasse enviar uma mensagem, seria necessário realizar uma chamada ao \emph{endpoint} correspondente. Neste sentido (Morpheus para nuvem) não há nenhum problema, pois é possível garantir as configurações avançadas de segurança adequadas, bem como a utilização de balanceadores de carga e servidores terceiros para lidar com ataques do tipo DoS \cite{akamai}, conforme RNF-6.

O problema, no entanto, está em garantir a segurança e usabilidade do lado da casa. Primeiramente, os IPs residenciais não são fixos, sendo trocados a cada nova conexão. Assim, se a conexão com a Internet for perdida, por exemplo, um novo IP será atribuído àquela residência. Dessa forma, após essa troca, a não ser que o Morpheus atualize a nuvem, não seria possível receber as mensagens que chegariam dos serviços remotos. Esta questão, no entanto, é contornável por meio de um serviço de \emph{watchdog}, que seria responsável por analisar o IP e notificar a nuvem sobre a troca sempre que esta ocorrer. Há, ainda, um problema mais grave e mais difícil de ser contornado. Com essa arquitetura, o Morpheus também seria um servidor do ponto de vista da nuvem, e qualquer dispositivo poderia tentar fazer uma requisição em um dos \emph{endpoints} disponíveis. Mesmo que sejam checados os dados da requisição para garantir que ela seja válida, tem-se ainda uma grave ameaça de segurança em relação à negação de serviço. Para que este risco fosse minimizado, seriam necessárias configurações avançadas no roteador local, e, mesmo assim, este não seria suficiente para processar um grande número de requisições, deixando a casa vulnerável.

Uma forma de contornar o problema se encontra no uso de WebSockets, protocolo detalhado na Seção \ref{sub:websocket}. Assim, o Morpheus se comporta como um cliente em relação à nuvem e é sempre ele que abre uma conexão. Essa conexão se mantém aberta e forma um caminho \emph{full-duplex}, de modo que é possível receber as mensagens da nuvem a qualquer momento também. Com essa arquitetura, os desafios relativos à segurança recaem aos servidores e não mais à casa, de modo que é possível gerenciar esses riscos como o fazem grandes empresas, ou seja, de forma transparente ao cliente final.

\subsection{Comunicação entre Nuvem e Aplicativos}

Similarmente à comunicação entre controlador local e nuvem, a troca de informações entre nuvem e aplicativos clientes em geral é feita por meio de WebSockets. Como aplicações web podem ter como requisito oferecer suporte à navegadores mais antigos, é usado um \emph{fallback} para um mecanismo de \emph{polling} caso não haja suporte para WebSockets.

\subsection{Comunicação entre Módulos e Aplicativos}

Em caso de indisponibilidade da rede local ou internet, a comunicação é feita diretamente entre módulos e aplicativo backup com escopo local (por meio de HTTP). Esse canal de comunicação fica aberto para uso somente nesses casos, para evitar exposição desnecessária a possíveis ataques. O módulo atua como servidor e o aplicativo como cliente, sendo que cada aplicativo pode se conectar diretamente ao módulo que desejar.

\subsection{Diagramas de sequência}

Seguem diagramas de sequência UML para ilustrar a comunicação fim-a-fim utilizada no projeto:

\begin{figure}[H]
	\centering
	\caption{Diagrama de sequência - transmissão de dados}
	\includegraphics[width=1\textwidth]{sequencia_data}
	\label{fig:sequencia_data}
\end{figure}

No sistema instalado nas residências para coleta de dados, ocorre atualização a cada 1 minuto. No caso de mudança considerável no estado de algum sensor ou acionamento de algum relé, há uma atualização para o aplicativo com tempo de resposta de 1 segundo.

Para os casos de mudança de configuração e atuação (acionamento de relés), temos:

\begin{figure}[H]
	\centering
	\caption{Diagrama de sequência - configuração e requisição de ação}
	\includegraphics[width=1\textwidth]{sequencia_action_configuration}
	\label{fig:sequencia_action_configuration}
\end{figure}

Se não houver conexões disponíveis, os procedimentos de atualização de estado de dados, requisição de ação e configuração ocorrem diretamente entre módulos e aplicativos. O usuário ainda pode atuar no sistema através de controles de rádio frequência e botões físicos, utilizando uma comunicação direta entre usuário e módulo (sem uso do aplicativo).

\begin{figure}[H]
	\centering
	\caption{Diagrama de sequência - transmissão de dados do Aplicativo Backup}
	\includegraphics[width=1\textwidth]{app_backup-sequencia_data}
	\label{fig:app_backup-sequencia_data}
\end{figure}

\begin{figure}[H]
	\centering
	\caption{Diagrama de sequência - configuração e requisição de ação do Aplicativo Backup}
	\includegraphics[width=1\textwidth]{app_backup-sequencia_action_configuration}
	\label{fig:app_backup-sequencia_action_configuration}
\end{figure}

É importante destacar que não há possibilidade do usuário requisitar múltiplos acionamentos (causando muitas trocas de estado em um período pequeno de tempo), uma vez que a requisição é realizada a partir do estado atual do relé (dessa forma, se este estiver ativo, múltiplos cliques do usuário mandam a requisição ``desligar'').

Outro ponto é a inclusão de um mecanismo simples para segurança do sistema, mesmo no canal de comunicação emergencial de escopo local, mostrando uma possibilidade de aumento do nível de segurança do sistema (maiores detalhes estão na seção \ref{ssec:acessomodulo}).

\begin{figure}[H]
	\centering
	\caption{Diagrama de sequência - requisição de ação com senha no Aplicativo Backup}
	\includegraphics[width=1\textwidth]{app_backup-sequencia_action_seg}
	\label{fig:app_backup-sequencia_action_seg}
\end{figure}
\section{Controlador Local}
Para a intercomunicação entre os módulos e a nuvem, existe o servidor local, Morpheus, responsável por introduzir mais uma camada de segurança na troca de mensagens. Para isso, foi desenvolvida uma plataforma com a utilização de sistemas de mensageria, e foi definido um protocolo de comunicação entre os serviços de nuvem e os módulos. Assim, quando um usuário realiza determinada operação por meio do cliente web, uma mensagem é enviada, interpretada pelo servidor local e, em seguida, encaminhada para o destino por meio do protocolo \wmqtt{} com o broker Mosquitto. O Morpheus é visto em detalhe na Seção \ref{chap:morpheus}.

\subsection{Raspberry Pi}
O Raspberry Pi é um computador integrado em um único chip, do tamanho de um cartão de crédito. Foi desenvolvido com o objetivo de promover o ensino de computação básica, e possui funcionalidades tais como as de um computador pessoal (PC): navegação na Internet, reprodução de vídeo, processamento de texto, dentre outros. No projeto, é utilizado como servidor local (gerenciador de módulos local da casa), exatamente pelas funcionalidades compatíveis com a de um computador desktop.

A versão 3 possui uma CPU 1.2 Ghz 64-bit quad-core ARMv8, conexão 802.11n Wireless LAN, Bluetooth 4.1, suporte a \emph{Bluetooth Low Energy} (BLE), 1GB RAM, 4 portas USB, 40 pinos GPIO, porta HDMI, porta Ethernet, interface para câmera, display e cartão SD. Para projetos que necessitem de baixo consumo energético, os modelos mais indicados são Pi Zero ou A+ \cite{raspPi}.

\begin{figure}[H]
	\centering
	\caption{Raspberry Pi 3 Modelo B}
  \includegraphics[width=0.5\textwidth]{Raspberry-Pi-3}
	\caption*{Fonte: \cite{raspPi}}
\label{fig:Raspberry-Pi-3}
\end{figure}
